#!/bin/bash
#
#  Name: lookup_api_error_handling
#
#  Description: Test of hpl_entity_path_lookup error-handling functionaliy.
# 
#  Notes:
#	 Uses ../src/hpl_entity_lookup binary to make API calls.
#
#    Tests the output of the API for each of the path types.
#
#      -*- OpenSAF  -*-
#
# (C) Copyright 2008 The OpenSAF Foundation
#
# This program is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
# or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
# under the GNU Lesser General Public License Version 2.1, February 1999.
# The complete license can be accessed from the following location:
# http://opensource.org/licenses/lgpl-license.php
# See the Copying file included with the OpenSAF distribution for full
# licensing terms.
#
# Author(s):
#           Hewlett-Packard Company
#
################################################################################

#*******************************************************************************
#                             Common Environment
#*******************************************************************************
shopt -s extglob 		# POSIX regular expression matches
#*******************************************************************************
#                                  Libraries
#*******************************************************************************
 # Figure out where the libraries are located and source them
declare MyPath=$(which ${0##*/} | sed -e "s:/[^/]*$::")
[[ -z $LIB_PATH ]] && export LIB_PATH=${MyPath}/../lib
if [[ -s $LIB_PATH/libTestUtils ]]
then
   . $LIB_PATH/libTestUtils
else
   echo -e "\n**>ERROR: Couldn't find libTestUtils"
   exit 1
fi
if [[ -s $LIB_PATH/libHisvApi ]]
then
   . $LIB_PATH/libHisvApi
else
   echo -e "\n**>ERROR: Couldn't find libHisvApi"
   exit 1
fi

#*******************************************************************************
#                          Global and Default Variables
#*******************************************************************************
 # Test-related Global variables
export APItest=hpl_entity_lookup
# This is the expected path output
export -a ExpectedPath
# This is the path gotten from the API
export -a EntityPath

#*******************************************************************************
#                              Local Subroutines
#*******************************************************************************
function fCheckInput
{
	if [[ -z $Chassis ]]
	then
		fErrorExit "Valid chassis not set in the configuration file"
	fi	
}

#*******************************************************************************
#                                    MAIN
#*******************************************************************************

trap 'fCleanup' EXIT

 # Print the system configuration
fShowConfig

 # Get the user's data
fParseCmdline $*

if [[ -z $ConfigFile ]]
then
    ConfigFile=$DefaultConfigFile
    fWarn "User didn't input config file, using default, $ConfigFile"
fi

 # Verify whether or not the test should be run
fCheckRunTest
 # Read the data from the configuration file
if ! fReadCfgFile $ConfigFile
then
    fErrorExit $SKIPPED "Failed to read $ConfigFile"
fi

fCheckInput

 #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::
 #                                 Run Tests
 #::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::

 # Set up entity-enum values (done here, since we need to
 # parse -dryrun on the command line first:
export BladeEntityType=$($HpiHeaderParser $HpiBladeEntity)
export ChassisEntityType=$($HpiHeaderParser $HpiChassisEntity)
export RootEntityType=$($HpiHeaderParser $HpiRootEntity)

  # Print the test header
fInitTest "Entity-Path Lookup API Error-Handling Tests"


declare pathType
declare blade=$PayloadBlade

# First test group
declare TestGroup=1
fPrintHeader "Test Group $TestGroup : Invalid Chassis ID and Valid blade ID" 1
declare chassisID
for chassisID in -1 32
do
	declare subTest=0
	for pathType in 0 1 2 3
	do
		(( subTest++ ))
		fBeginTest "${TestGroup}.${subTest} Path lookup type $pathType for blade $Blade/invaild chassis $chassisID"
		fRunLookupTest -c $chassisID -b 12 -t $pathType -fail 1
		fEndTest
	done
done

# Second test group
(( TestGroup++ )) 

fPrintHeader "Test Group $TestGroup : Valid Chassis ID and Invalid blade ID" 1
declare blade
for blade in -1 42
do
	declare subTest=0
	for pathType in 0 1 2 3
	do
		(( subTest++ ))
		fBeginTest "${TestGroup}.${subTest} Path lookup type $pathType for invalid blade $blade/chassis $Chassis"
		fRunLookupTest -c $Chassis -b $blade -t $pathType -f -lexp $LogEntityError
		fEndTest
	done
done


# Third test group
(( TestGroup++ )) 

fPrintHeader "Test Group $TestGroup : Invalid lookup type"
declare pathType
for pathType in -1 7
do
	declare subTest=1
	fBeginTest "${TestGroup}.${subTest} Path lookup type $pathType for valid blade $Blade/chassis $Chassis"
	fRunLookupTest -c $Chassis -b $blade -t $pathType -f
	fEndTest
done


# Fourth test group
(( TestGroup++ )) 

fPrintHeader "Test Group $TestGroup : buffer is too small"
declare buffSize
for buffSize in 0 8
do
	declare subTest=0
    (( subTest++ ))
	fBeginTest "${TestGroup}.${subTest} Path lookup type $pathType for blade $Blade/chassis $Chassis in $buffSize B buffer"
	fRunLookupTest -c $Chassis -b $blade -t $pathType -length $buffSize -f
	fEndTest
done

#  Test is done, exit with the appropriate value
exit $EXIT_VAL



##
# vim: tabstop=4
# -*- tab-width:4 -*-
##
