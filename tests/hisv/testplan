Test Plan for HISv on c-Class Blades
Jan Ariyasu
Hewlett Packard Co.
====================================

Introduction:
=============
    Requirement Summary:
    --------------------
    HISv must enable basic power and reset-control functionality on
    HP c-Class enclosures and carrier-grade server blades using the
    OpenHPI functionality supported by the OA-soap plugin incorporated
    in OpenHPI release 2.11.3 and newer.  The power-control
    functionality includes power-off, power-on and power-cycle
    of resources.  The reset-control functionality encompasses warm
    (toggle reset line to the CPU), cold (power-cycle) and assertive
    (power-cycle) resets.

    HISv must also accurately report OpenHPI events on HP c-Class
    and carrier-grade server blades.  The events include sensor
    and hot-swap events.

    Test Coverage:
    --------------
    Testing is broken up into two categories: tests of power
    control and tests of reset control.  These categories
    are further subdivided into API tests and tests of the
    command-line interface (CLI).  Power-control API testing
    covers the function hpi_resource_power_set() and the
    function hpl_entity_path_lookup().  Reset-control testing
    will cover the function hpi_resource_reset() and the function
    hpl_entity_path_lookup().

    Included in the power-and reset-control tests is event reporting:
    When a resource's power state changes, it goes through a
    series of hot-swap states that are published as events via HPI.
    The tests verify that HISv detects these events appropriately.

    API tests cover functionality, error reporting and error
    handling.  Each of the API arguments will be varied among valid
    and invalid values.  Functional tests cover correct action
    and appropriate event reporting.  Error reporting and handling
    includes appropriate error return values from the APIs and that
    no action is taken.


    Test Prerequisites:
    -------------------
    These tests were developed for HP blade systems in c-Class
    enclosures, or their carrier-grade equivalents. 

      Software Prerequisites:
      -----------------------
      Besides the software packages required to build and install
      OpenSAF, these tests require installation of Expect (the
      revision that is supported under RHEL5.x is fine).

      These tests were run on OpenSAF 3.0.0 beta 3, built and running
      on Red Hat Enterprise Linux 5.x.	HISv for this test relies on
      OpenHPI, revision 2.12.0 or newer.  See the README file for
      details of configuration for OpenHPI and OpenSAF.


Test Descriptions:
==================
General methodology:  The tests are designed to be run from the active
controller and will target a payload node and the standby controller.
Input parameters for the test will be read from a test-configuration 
file.  This file can be specified on the command line, or will be 
test.dat by default.

For concreteness in the test descriptions below, the systems are in the
chassis with chassis ID 2; the standby controller is in bay 10, and
the payload node is in bay 12.

 ---------------------------------------------------------------------
 |   System    |  Blade |          Shortened Entity Path             |
 |             |   ID   |                  (type 3)                  |
 =====================================================================
 |   Standby   |        |                                            |
 | Controller  |   10   |  "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}"  |
 ---------------------------------------------------------------------
 |   Payload   |   12   |  "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}"  |
 ---------------------------------------------------------------------


API Tests
---------
  Power Control:
  ~~~~~~~~~~~~~~
    Test Code:
    The API test covers valid and invalid arguments for the three
    arguments to the API,
    hpl_resource_power_set(uns32 chassis_id, uns8 *entity_path, uns32 power_state);

    The test code to access the parameters of the power function is
    hisv_power_ctrl.c, which does the following:
        - Parses user input.
        - Checks for input validity (unless -force is indicated on
          the command line).
        - Registers the application with the Event Distribution
          Service (EDSv) to open a HPI session to receive publish
          HPI events.
        - Initializes the client-side HISv library.
        - Calls the power-set function with the parameters input by
          the user.

    Command-line options for hisv_power_ctrl.c are
        -chassis <chassis_id> (integer) This is the numerical
                            value in /etc/opensaf/chassis_id.
                            This is the first parameter of the
                            API under test.  (Default is 2)

        -path <entity_path> (string) The shortened entity path
                            for the target system.  This option
                            must be passed in quotes to prevent
                            shell expansion.  This is the second
                            argument of the API under test.

        -on                 (no argument) Turn the system on.
        -off                (no argument) Turn the system off.
        -cycle              (no argument) Power-cycle the system.

        -state <state>      (integer or string) Set the system power
                            state to the specified value, where

                                off         -> 0
                                on          -> 1 
                                power-cycle -> 2

                            The appropriate translation to state number
                            performed when parsing the option to -state.
                            This is the third parameter passed to the 
                            API under test.

        -blade <blade_id>   (integer) The location (bay) where the
                            target system is located in the enclosure.
                            When this option is given, the entity path
                            is generated from hpl_entity_path_lookup().

        -force              (no arguments) Skip input-validity testing
                            This is used for tests of API error-handling.
                            User input checking is performed to insure
                            that tests don't fail because of malformed
                            command lines. 

    Functional Testing:
        Functional testing is performed in the test-file power_api,
        This test suite verifies correct action with valid parameters
        to hpl_resource_power_set().  This suite is comprised of
        twelve tests.

        For each test:
        - Verify that the function returns successful completion
          (return value of NCSCC_RC_SUCCESS).
        - Verify that only the correct system's power state changes
          and that the power state changes to the requested state.
        - Verify that the actions are logged in the HISv-log file.
        - Verify that the correct hot-swap states are reported in
          the HISv-log file.
        - Verify that no errors are reported in the HISv-log file [3].

       Individual tests:
         Group 1, using entity paths,
         1.  Power the payload blade off,
             hpl_resource_power_set(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 0);
         2.  Power the payload blade on
             hpl_resource_power_set(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 1);
         3.  Power-cycle the payload blade
             hpl_resource_power_set(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 2);
         4.  Power the standby-controller blade off,
             hpl_resource_power_set(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 0);
         5.  Power the standby-controller blade on
             hpl_resource_power_set(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 1);
         6.  Power-cycle the standby-controller 
             hpl_resource_power_set(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);

         Group 2, using the path returned by hpl_entity_path_lookup(),
         1.  Power the payload blade off,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_power_set(2, entity_path, 0);
         2.  Power the payload blade on
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_power_set(2, entity_path, 1);
         3.  Power-cycle the payload blade
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_power_set(2, entity_path, 2);
         4.  Power the standby-controller blade off,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_power_set(2, entity_path, 2);
         5.  Power the standby-controller blade on
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_power_set(2, entity_path, 1);
         6.  Power-cycle the standby-controller 
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_power_set(2, entity_path, 2);

   Error Handling:
       The error-handling-test suite is power_api_error_handling.
       These tests verify the robustness of hpl_resource_power_set()
       to invalid input, and consists of 40 tests.

       For each test:
       - Verify that the API returns an error (return value of 
         NCSCC_RC_FAILURE).
       - Verify that the power state of each system in the cluster
         remains unchanged.  Note that the default for all tests is
         to verify the power state of each system in the enclosure
         remain unchanged, but if systems outside of the cluster are
         changing power state independently, power-state verification
         can be limited to systems in the OpenSAF cluster by using
         the Cluster definition in the test-parameter file.
       - Verify that errors are reported in the HISv-log file [3].
       - Verify that no hot-swap changes are reported in the HISv-log
         file.

       Individual tests:
         Group 1, invalid chassis ID (invalid type and invalid number).
         Set power state to each of off, on and power-cycle passing
         the valid entity path for each of the payload and standby
         controller.

         1. Try to set the power state using a valid entity path and
            an invalid number for the chassis ID (-1 for uns32),
            payload path:
            hpl_resource_power_set(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_power_set(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_power_set(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 2);
            standby-controller path:
            hpl_resource_power_set(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_power_set(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_power_set(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);

         2. Try to set the power state using a valid entity path and
            a reasonable chassis ID, but one that is not configured for
            the cluster. 
            payload:
            hpl_resource_power_set(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_power_set(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_power_set(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 2);
            standby controller:
            hpl_resource_power_set(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_power_set(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_power_set(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);
         
       Group 2, bad entity path (NULL and non-existent paths).
       Set the power state to each of off, on and power-cycle passing the valid
       chassis ID.
         1. Try to set the power state using the valid chassis ID, and a NULL
            pointer as the second argument of hpl_resource_power_set()
            hpl_resource_power_set(2, NULL, 0);
            hpl_resource_power_set(2, NULL, 1);
            hpl_resource_power_set(2, NULL, 2);
         2. Try to set the power state using an invalid path,
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,20},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,20},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,20},{SYSTEM_CHASSIS,2}}", 2);

       Group 3, invalid power state. (invalid numbers -1, 8). 
       Set the power state using the valid payload and standby controller entity-paths
       and the valid chassis ID.
            payload:
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", -1);
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 8);
            standby controller:
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", -1);
            hpl_resource_power_set(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 8);

       Group 4, invalid blade ID using hpl_entity_path_lookup():
       Set the power state to each of off, on and power-cycle using the path returned
       by hpl_entity_path_lookup() for an invalid blade ID (and valid chassis id).
          Blade ID 0:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 2, 0, entity_path, sizeof(entity_path));
            hpl_resource_power_set(2, entity_path, 0);
            hpl_resource_power_set(2, entity_path, 1);
            hpl_resource_power_set(2, entity_path, 2);

          Blade ID 17:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 2, 17, entity_path, sizeof(entity_path));
            hpl_resource_power_set(2, entity_path, 0);
            hpl_resource_power_set(2, entity_path, 1);
            hpl_resource_power_set(2, entity_path, 2);

       Group 5, invalid chassis ID using hpl_entity_path_lookup():
       Set the power state to each of off, on and power-cycle using the path returned
       by hpl_entity_path_lookup() for an invalid chassis ID (and valid blade id).
          Chassis ID -1:
            payload-blade ID:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, -1, 12, entity_path, sizeof(entity_path));
            hpl_resource_power_set(2, entity_path, 0);
            hpl_resource_power_set(2, entity_path, 1);
            hpl_resource_power_set(2, entity_path, 2);

            standby-controller-blade ID:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, -1, 10, entity_path, sizeof(entity_path));
            hpl_resource_power_set(2, entity_path, 0);
            hpl_resource_power_set(2, entity_path, 1);
            hpl_resource_power_set(2, entity_path, 2);

          Chassis ID 32:
            payload-blade ID:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 32, 12, entity_path, sizeof(entity_path));
            hpl_resource_power_set(2, entity_path, 0);
            hpl_resource_power_set(2, entity_path, 1);
            hpl_resource_power_set(2, entity_path, 2);

            standby-controller-blade ID:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 32, 10, entity_path, sizeof(entity_path));
            hpl_resource_power_set(2, entity_path, 0);
            hpl_resource_power_set(2, entity_path, 1);
            hpl_resource_power_set(2, entity_path, 2);

  Reset Control:
  ~~~~~~~~~~~~~~
    Test Code:
    The API test covers valid and invalid arguments for the three
    arguments to the API,
    hpl_resource_reset(uns32 chassis_id, uns8 *entity_path, uns32 power_state);

    The test code to access the parameters of the power function is
    hisv_reset_ctrl.c, which does the following:
        - Parses user input.
        - Checks for input validity (unless -force is indicated on
          the command line).
        - Registers the application with the Event Distribution
          Service (EDSv) to open a HPI session to receive publish
          HPI events.
        - Initializes the client-side HISv library.
        - Calls the reset function with the parameters input by
          the user.

    Command-line options for hisv_reset_ctrl.c are
        -chassis <chassis_id> (integer) This is the numerical
                            value in /etc/opensaf/chassis_id.
                            This is the first parameter of the
                            API under test.  (Default is 2)

        -path <entity_path> (string) The shortened entity path
                            for the target system.  This option
                            must be passed in quotes to prevent
                            shell expansion.  This is the second
                            argument of the API under test.

        -cold               (no argument) Perform cold reset.
        -warm               (no argument) Perform warm reset.
        -assert             (no argument) Perform assert reset.
                            From the AVSv Programmer's Guide, this
                            reset is used for hot swap functionality
                            and is the equivalent to holding the
                            reset line low, and is implemented by
                            turning the system off.
        -deassert           (no argument) Perform deassert reset.
                            From the AVSv Programmer's Guide, this
                            reset is used for hot swap functionality
                            and is the equivalent to bringing the
                            voltage back up on the reset line, and
                            is implemented by turning the system on.
        -reboot             (no argument) Perform graceful-reboot
                            reset.

        -reset <type>       (integer or string) Use the reset type
                            specified, where

                                cold               -> 0
                                warm               -> 1 
                                assert             -> 2
                                deassert           -> 3
                                graceful-reboot    -> 4

                            The appropriate translation to reset type
                            is performed when parsing the option to 
                            -reset.
                            This is the third parameter passed to the 
                            API under test.

        -blade <blade_id>   (integer) The location (bay) where the
                            target system is located in the enclosure.
                            When this option is given, the entity path
                            is generated from hpl_entity_path_lookup().

        -force              (no arguments) Skip input-validity testing
                            This is used for tests of API error-handling.
                            User input checking is performed to insure
                            that tests don't fail because of malformed
                            command lines. 

    Functional Testing:
       The suite of functional tests is in reset_api, and verifies the
       correct actio of the API with valid parameters.  The functional
       test suite consists of 20 tests.

       For each test:
       - Verify that the specified system is reset.
       - Verify that the correct reset type is applied.
       - Verify that the actions are logged in the HISv-log file.
       - Verify that the correct hot-swap states are reported in
         the hisv-log file for resets that change power state (cold,
         assert and deassert).
       - Verify that no errors are reported in the HISv-log file [3].

       Individual tests:
         Group 1, using entity paths,
         1.  Cold reset the payload blade.
             hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 0);
         2.  Warm reset the payload blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 1);
         3.  Apply an assert reset to the payload blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 2);
         4.  Apply a de-assert reset to the payload blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 3);
         5.  Apply an OS-reboot reset to the payload blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 4);
         6.  Cold reset the standby-controller blade.
             hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 0);
         7.  Warm reset the standby-controller blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 1);
         8.  Apply an assert reset to the standby-controller blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);
         9.  Apply a de-assert reset to the standby-controller blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);
        10.  Apply an OS-reboot reset to the standby-controller blade,
             hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 4);

         Group 2, using the result of hpl_entity_path_lookup(),
         1.  Cold reset the payload blade.
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 0);
         2.  Warm reset the payload blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 1);
         3.  Apply an assert reset to the payload blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 2);
         4.  Apply a de-assert reset to the payload blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 3);
         5.  Apply an OS-reboot reset to the payload blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 4);
         6.  Cold reset the standby-controller blade.
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 0);
         7.  Warm reset the standby-controller blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 1);
         8.  Apply an assert reset to the standby-controller blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 2);
         9.  Apply a de-assert reset to the standby-controller blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 3);
        10.  Apply an OS-reboot reset to the standby-controller blade,
             SaUint8T entity_path[EPATH_STRING_SIZE];
             hpl_entity_path_lookup(3, 2, 10, entity_path, sizeof(entity_path));
             hpl_resource_reset(2, entity_path, 4);

   Error Handling:
       The error-handling-test suite is reset_api_error_handling.
       These tests verify the robustness of hpl_resource_reset()
       to invalid input, and consists of 64 tests.

       For each test:
       - Verify that the API returns an error.
       - Verify that the power state of each system in the cluster
         remains unchanged.  Note that the default for all tests is
         to verify the power state of each system in the enclosure
         remain unchanged, but if systems outside of the cluster are
         changing power state independently, power-state verification
         can be limited to systems in the OpenSAF cluster by using
         the Cluster definition in the test-parameter file.
       - Verify that errors are reported either when making the API 
         call or in the HISv-log file [3].
       - For any test using a valid entity path or chassis and blade ID,
         verify that the system with those parameters are not reset.
    
       Individual tests:
         Group 1, bad chassis ID (invalid numbers -1 and 32), valid
         entity path and reset type.
         1. Try to apply a defined reset type to a system with chassis
            ID -1 (in an uns32),
            payload entity path:
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 2);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 3);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 4);

            standby-controller entity path:
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 3);
            hpl_resource_reset(-1, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 4);

         2. Try to apply a defined reset type using a valid entity path and
            a reasonable chassis ID, but one that is not configured for
            the cluster. 
            payload:
            hpl_resource_reset(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 2);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 3);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 4);

            standby controller:
            hpl_resource_reset(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 0);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 1);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 2);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 3);
            hpl_resource_reset(32, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 4);
         
         Group 2, bad entity path (NULL and non-existent paths), valid chassis
         ID for each reset type.
         1. Try to apply a defined reset type to a system with invalid entity
            path (NULL pointer) and valid chassis ID.
            hpl_resource_reset(2, NULL, 0);
            hpl_resource_reset(2, NULL, 1);
            hpl_resource_reset(2, NULL, 2);
            hpl_resource_reset(2, NULL, 3);
            hpl_resource_reset(2, NULL, 4);

         Group 3, valid chassis ID, valid entity path and invalid reset types
         -1 and 16.
         1. Try to apply reset type -1 (in uns32 parameter slot).
            payload entity path:
            hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", -1);

            standby-controller entity path:
            hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", -1);

         2. Try to apply reset type 16:
            payload entity path:
            hpl_resource_reset(2, "{{SYSTEM_BLADE,12},{SYSTEM_CHASSIS,2}}", 16);
            standby-controller entity path:
            hpl_resource_reset(2, "{{SYSTEM_BLADE,10},{SYSTEM_CHASSIS,2}}", 16);

       Group 4, invalid blade ID using hpl_entity_path_lookup():
       Try to apply a valid reset using the path returned by
       hpl_entity_path_lookup() for an invalid blade ID (and valid
       chassis ID).
          Blade ID 0:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 2, 0, entity_path, sizeof(entity_path));
            hpl_resource_reset(2, entity_path, 0);
            hpl_resource_reset(2, entity_path, 1);
            hpl_resource_reset(2, entity_path, 2);
            hpl_resource_reset(2, entity_path, 3);
            hpl_resource_reset(2, entity_path, 4);

          Blade ID 17:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 2, 17, entity_path, sizeof(entity_path));
            hpl_resource_reset(2, entity_path, 0);
            hpl_resource_reset(2, entity_path, 1);
            hpl_resource_reset(2, entity_path, 2);
            hpl_resource_reset(2, entity_path, 3);
            hpl_resource_reset(2, entity_path, 4);

       Group 5, invalid chassis ID using hpl_entity_path_lookup():
       Try to apply a valid reset using the path returned by
       hpl_entity_path_lookup() for an invalid chassis ID (and valid
       blade ID).
          Chassis ID -1:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, -1, 32, entity_path, sizeof(entity_path));
            hpl_resource_reset(2, entity_path, 0);
            hpl_resource_reset(2, entity_path, 1);
            hpl_resource_reset(2, entity_path, 2);
            hpl_resource_reset(2, entity_path, 3);
            hpl_resource_reset(2, entity_path, 4);

          Chassis ID 32:
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(3, 32, 32, entity_path, sizeof(entity_path));
            hpl_resource_reset(2, entity_path, 0);
            hpl_resource_reset(2, entity_path, 1);
            hpl_resource_reset(2, entity_path, 2);
            hpl_resource_reset(2, entity_path, 3);
            hpl_resource_reset(2, entity_path, 4);

  Entity Path Lookup:
  ~~~~~~~~~~~~~~~~~~~
    Test Code:
    The API test covers valid and invalid arguments for the five
    arguments to the API,
    hpl_entity_path_lookup(uns32 flag, uns32 chassis_id, uns32 blade_id, uns8 *entity_path, size_t entity_path_size)

    The test code to access the parameters of the power function is
    hpl_entity_lookup.c, which does the following:
        - Parses user input.
        - Checks for input validity (unless -force is indicated on
          the command line).
        - Registers the application with the Event Distribution
          Service (EDSv) to open a HPI session to receive publish
          HPI events.
        - Initializes the client-side HISv library.
        - Calls the entity-path-lookup function with the parameters
          input by the user.

    Command-line options for hisv_power_ctrl.c are
        -type <lookup_type> (integer or string) The entity-path types
                            returned by the API are,
                              full string        -> 0
                              numeric string     -> 1
                              SaHpiEntityPathT   -> 2
                              (a structure whose member is an array of
                              SaHpiEntitT structures).
                              short string path  -> 3

                             the non-numeric lookup types recognized
                             by hpl_entity_lookup are, 
                               "string"          -> 0
                               "numeric"         -> 1
                               "array"           -> 2
                               "short"           -> 3

                            The appropriate translation to path type is
                            performed when parsing the option to -state.
                            This is the first parameter passed to the 
                            API under test.

        -chassis <chassis_id> (integer) This is the numerical
                            value in /etc/opensaf/chassis_id.
                            This is the second parameter of the API 
                            under test.  (Default is 2)

        -blade <blade_id>   (integer) The location (bay) where the
                            target system is located in the enclosure.
                            When this option is given, the entity path
                            is generated from hpl_entity_path_lookup().

        -length <path_length> (integer) This is the size of the uns8
                            array to allocate for the entity path.
                            (Default is EPATH_STRING_SIZE)
                            This array is passed as the fourth parameter
                            to hpl_entity_path_lookup().
                            This is also determines the fifth parameter
                            in the API under test (via sizeof()).

        -force              (no arguments) Skip input-validity testing
                            This is used for tests of API error-handling.
                            User input checking is performed to insure
                            that tests don't fail because of malformed
                            command lines. 

    Functional Testing:
      Functional testing is performed in the test-file lookup_api.
      This test suite verifies correct action with valid parameters to
      hpl_entity_path_lookup().  This suite is comprised of four tests.
      In addition, the output of the function for entity-paths type of
      3 (short string) is extensively tested in the path-lookup test
      cases for hpl_resource_power_set() and hpl_resource_reset(),
      as described above.

      For each test:
        - Generate the expected entity path.
        - Verify that the path returned by the API matches the expected
          result.
        - Verify that the actions are logged in the HISv-log file.
        - Verify that no errors are reported in the HISv-log file [3].

       1. Generate the full-HPI-entity-path string for valid chassis
          ID and valid blade ID,
          SaUint8T entity_path[EPATH_STRING_SIZE];
          hpl_entity_path_lookup(0, 2, 32, entity_path, sizeof(entity_path));
       2. Generate the numeric-entity-path string for valid chassis
          ID and valid blade ID,
          SaUint8T entity_path[EPATH_STRING_SIZE];
          hpl_entity_path_lookup(1, 2, 32, entity_path, sizeof(entity_path));
       3. Generate the SaEntityPathT-entity-path for valid chassis
          ID and valid blade ID,
          SaUint8T entity_path[EPATH_STRING_SIZE];
          hpl_entity_path_lookup(2, 2, 32, entity_path, sizeof(entity_path));
       4. Generate the short-HPI-entity-path string for valid chassis ID
          and valid blade ID,
          SaUint8T entity_path[EPATH_STRING_SIZE];
          hpl_entity_path_lookup(3, 2, 32, entity_path, sizeof(entity_path));

   Error Handling:
       The error-handling-test suite is lookup_api_error_handling.
       These tests verify the robustness of hpl_entity_path_lookup()
       to invalid input, and consists of 20 tests.

       For each test:
       - Verify that the API returns an error (return value of 
         NCSCC_RC_FAILURE) or a zero-length string.
       - Verify that errors are reported in the HISv-log file [3].

       Individual tests:
         Group 1, invalid chassis ID (invalid type and invalid number).
         1. Try to get the entity path using a valid blade ID,
            an invalid number for the chassis ID (-1 for uns32),
            and a buffer of EPATH_STRING_SIZE,
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(0, -1, 32, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(1, -1, 32, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(2, -1, 32, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(3, -1, 32, entity_path, sizeof(entity_path));

         2. Try to get the entity path using a valid blade ID and
            a reasonable chassis ID, but one that is not configured
            for the cluster.
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(0, 32, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(1, 32, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(2, 32, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(3, 32, 12, entity_path, sizeof(entity_path));

         Group 2, invalid blade ID, valid chassis ID and a buffer
         of EPATH_STRING_SIZE,
         1. Try to get the entity path using a valid chassis ID, and
            an invalid number for the blade ID (-1 in uns32),
            and a buffer of EPATH_STRING_SIZE,
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(0, 2, -1, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(1, 2, -1, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(2, 2, -1, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(3, 2, -1, entity_path, sizeof(entity_path));

         2. Try to get the entity path using a valid chassis ID and
            a uns32 blade ID, but one that is not configured for
            the cluster.
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(0, 2, 32, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(1, 2, 32, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(2, 2, 32, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(3, 2, 32, entity_path, sizeof(entity_path));

         Group 3, valid blade ID, valid chassis ID and a buffer, invalid
         lookup type path buffer of EPATH_STRING_SIZE,
         1. Try to get the entity path using a valid chassis and blade IDs, and
            an invalid number for the entity type (-1 in uns32),
            and a buffer of EPATH_STRING_SIZE,
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(-1, 2, 12, entity_path, sizeof(entity_path));

         2. Try to get the entity path using a valid chassis and blade IDs, and
            an nonexistent entity type, 7, and a buffer of EPATH_STRING_SIZE,
            SaUint8T entity_path[EPATH_STRING_SIZE];
            hpl_entity_path_lookup(7, 2, 12, entity_path, sizeof(entity_path));

         Group 3, valid blade ID, valid chassis ID and a buffer, valid
         lookup type path buffer too small to hold any entity path.
         1. Try to get the entity path using a valid chassis and blade IDs, and
            and a buffer of 0 bytes,

            SaUint8T entity_path[0];
            hpl_entity_path_lookup(0, 2, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(1, 2, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(2, 2, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));

         2. Try to get the entity path using a valid chassis and blade IDs, and
            and a buffer of 8 bytes,
            SaUint8T entity_path[8];
            hpl_entity_path_lookup(0, 2, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(1, 2, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(2, 2, 12, entity_path, sizeof(entity_path));
            hpl_entity_path_lookup(3, 2, 12, entity_path, sizeof(entity_path));

Command-Line-Interface (CLI) Tests
----------------------------------

  Power Control:
  ~~~~~~~~~~~~~~
    Test Code:
    The CLI test covers valid and invalid arguments for the three
    arguments to the CLI admreq command.
       - Chassis ID
       - Blade ID
       - Power command (shutdown, lock and unlock)

    The test code to interface with the CLI is runCli, which does the
    following:
       - Parses user input.
       - Generates the appropriate power command
       - Starts the CLI
       - Enables commands,
       - Configures the terminal
       - Goes to the appropriate menu for power commands (avsv)
       - Runs the command
       - Detects success and error messages
       - Gracefully shuts down the cli.

    runCli takes the following command-line options related to power-
    state testing,
        -blade <blade_id>       The blade/bay number
        -chassis <chassis_id>   The chassis ID (the value in
                                /etc/opensaf/chassis_id)
        -off                    Graceful shutdown the system
                                (operation shutdown)
        -on                     Turn on the system (operation unlock)
        -lock                   Hard shut down of the system
                                (operation lock) 

    Functional Testing:
      Functional testing is performed in the test file power_cli,
      This test suite verifies correct action with valid parameters
      to the cli admreq command.  This suite is comprised of four
      tests.

        For each test:
        - Verify that the function completes successfully.
        - Verify that only the correct system's power state changes
          and that the power state changes to the requested state.
        - Verify that the actions are logged in the HISv-log file.
        - Verify that the correct hot-swap states are reported in
          the HISv-log file.
        - Verify that no errors are reported in the HISv-log file [3].

       Individual tests:
       1.  Power the payload blade off (graceful power off),
           admreq /2/12 operation shutdown
       2.  Power the payload blade on
           admreq /2/12 operation unlock
       3.  Power the standby-controller blade off (graceful power off),
           admreq /2/10 operation shutdown
       4.  Power the standby-controller blade on
           admreq /2/10 operation unlock
       5.  Power the payload blade off (hard power off),
           admreq /2/12 operation lock
       6.  Power the payload blade on
           admreq /2/12 operation unlock
       7.  Power the standby-controller blade off (hard power off),
           admreq /2/10 operation lock
       8.  Power the standby-controller blade on
           admreq /2/10 operation unlock

     Error Handling:
       Error handling tests cover robustness of the CLI to invalid
       input parameters.  These tests are performed in the test file,
       power_cli_error_handling, fifteen tests:
           For each test:
           - Verify that the CLI reports an error.
           - Verify that the power state of each system in the cluster
             remains unchanged.
           - Verify that errors are reported in the hisv-log file.

           Individual tests:
           1. Bad chassis ID (non-existent chassis), valid and invalid 
              blade IDs and power state.
              Chassis ID of -1 / blade ID 12:
              admreq /-1/12 operation shutdown
              admreq /-1/12 operation unlock
              admreq /-1/12 operation lock

              Chassis ID of 32 / blade ID 12:
              admreq /32/12 operation shutdown
              admreq /32/12 operation unlock
              admreq /32/12 operation lock

              Chassis ID -1 / blade ID 32
              admreq /-1/12 operation shutdown
              admreq /-1/12 operation unlock
              admreq /-1/12 operation lock

              Chassis ID of 32 / blade ID 32:
              admreq /32/32 operation shutdown
              admreq /32/32 operation unlock
              admreq /32/32 operation lock

           2. Bad blade ID (non-existent chassis), valid chassis ID.
              Blade ID -1 (invalid value):
              admreq /2/-1 operation shutdown
              admreq /2/-1 operation unlock
              admreq /2/-1 operation lock

              Blade ID 32 (nonexistent blade):
              admreq /2/32 operation shutdown
              admreq /2/32 operation unlock
              admreq /2/32 operation lock

           3. Bad power state (invalid operation)
              admreq /2/12 operation reboot
              admreq /2/10 operation reboot
              admreq /24/32 operation reboot


  Reset Control:
  ~~~~~~~~~~~~~~
    Test Code:
    The CLI test covers valid and invalid arguments for the three
    arguments to the CLI reset command.
       - Chassis ID
       - Blade ID
       - Reset command (softreset and softreset)

    The test code to interface with the CLI is runCli, which does the
    following:
       - Parses user input.
       - Generates the appropriate power command
       - Starts the CLI
       - Enables commands,
       - Configures the terminal
       - Goes to the appropriate menu for power commands (avsv)
       - Runs the command
       - Detects success and error messages
       - Gracefully shuts down the cli.

    runCli takes the following command-line options related to power-
    state testing,
        -blade <blade_id>       The blade/bay number
        -chassis <chassis_id>   The chassis ID (the value in
                                /etc/opensaf/chassis_id)
        -soft                   Perform a soft reset (operation
                                softreset)
        -hard                   Perform a hardreset

    Functional Testing:
      Functional testing is performed in the test file reset_cli,
      This test suite verifies correct action with valid parameters
      to the cli reset command.  This suite is comprised of four
      tests.

        For each test:
        - Verify that the function completes successfully.
        - Verify that only the correct system is reset.
        - Verify that the actions are logged in the HISv-log file.
        - Verify that no errors are reported in the HISv-log file [3].

       Individual tests:
       1.  Apply soft reset to the payload blade,
           reset /2/12 operation softreset
       2.  Apply hard reset to the payload blade,
           reset /2/12 operation hardreset
       3.  Apply soft reset to the standby-controller blade,
           reset /2/10 operation softreset
       4.  Apply hard reset to the standby-controller blade,
           reset /2/10 operation hardreset

     Error Handling:
       Error handling tests cover robustness of the CLI to invalid
       input parameters.  These tests are performed in the test file,
       power_cli_error_handling, fifteen tests:
           For each test:
           - Verify that the CLI reports an error.
           - Verify that the system is not reset for tests with
             valid entity data (chassis ID and blade ID).
           - Verify that errors are reported in the hisv-log file.

           Individual tests:
           1. Bad chassis ID (non-existent chassis), valid and invalid 
              blade IDs and power state.
              Chassis ID of -1 / blade ID 12:
              reset /-1/12 operation softreset
              reset /-1/12 operation hardreset

              Chassis ID of 32 / blade ID 12:
              reset /32/12 operation softreset
              reset /32/12 operation hardreset

              Chassis ID -1 / blade ID 32
              reset /-1/12 operation softreset
              reset /-1/12 operation hardreset

              Chassis ID of 32 / blade ID 32:
              reset /32/32 operation softreset
              reset /32/32 operation hardreset

           2. Bad blade ID (non-existent chassis), valid chassis ID.
              Blade ID -1 (invalid value):
              reset /2/-1 operation softreset
              reset /2/-1 operation hardreset

              Blade ID 32 (nonexistent blade):
              reset /2/32 operation softreset
              reset /2/32 operation hardreset

           3. Bad power state (invalid operation)
              reset /2/12 operation reboot
              reset /2/10 operation reboot
              reset /24/32 operation reboot

Foot Notes:
===========
[1] Use the configuration file
    /etc/opensaf/NCSSystemBOM.xml.hp.c-class, with
    the appropriate chassis_id number inserted at lines with tags
    <EntityLocation>.  See Appendix B in the README file.

[2] The entity_root variable in /etc/openhpi/openhpi.conf must have
    a chassis id consistent with values set up for <EntityLocation>
    in /etc/opensaf/NCSSystemBOM.xml, e.g.,
      entity_root = "{SYSTEM_CHASSIS,2}"
    See Appendix A in the README file.
   
[3] The following error messages are detected in the HISv log,
	/var/lib/opensaf/stdouts/ncs_hisv.log
    - Resource ID translations,
		"error getting resource-id"
	- Entity-path lookup failure, 
		"ham_entity_path_lookup: No match found",
		"hpl_entity_path_lookup.*did not find",
    - Failed to find a resource,
		"resource does not exist for give entity-path"
	- HISv applied the wrong reset,
		"error in saHpiResourceResetStateSet; Attempting"
	- HPI reported an error,
		""HPI error code"

[4] The following error messages are detected in API-code output
	- "No HAM managing chassis"
	  Invalid chassis ID used.
	- "MDS:ERR"
	   Message-distribution service had an error.
	- "Invalid Index"
	  Input to the CLI was invalid.
	- "hpl_entity_path_lookup.*did not find" 
	   The ".*" here is a regular expression matching anything.
	- "Invalid input detected"
	  Input to the CLI was invalid.
