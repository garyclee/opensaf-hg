/*      -*- OpenSAF  -*-
 *
 * (C) Copyright 2008 The OpenSAF Foundation
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
 * under the GNU Lesser General Public License Version 2.1, February 1999.
 * The complete license can be accessed from the following location:
 * http://opensource.org/licenses/lgpl-license.php
 * See the Copying file included with the OpenSAF distribution for full
 * licensing terms.
 *
 * Author(s): Emerson Network Power
 *
 */

/*****************************************************************************
..............................................................................
  
  ..............................................................................
 
  DESCRIPTION:This module deals wih registering AvM with MDS and provides the
  callbacks for MDS .
  ..............................................................................

  Function Included in this Module:

  ncsavmentdeploytableentry_set     -
  ncsavmentdeploytableentry_get     -
  ncsavmentdeploytableentry_extract -
  ncsavmentdeploytableentry_setrow  -
  ncsavmentdeploytableentry_next    -
******************************************************************************
*/

#include "avm.h"


static uns32
avm_octet_string_2_entity_path(
                                 uns8              *ep,
                                 uns32              length,
                                 SaHpiEntityPathT  *entity_path)
{
   uns8     i;
   uns32    entity_type;
   uns32    entity_instance;
   uns32    found = 0;
   uns8     count = 0;
   
   m_AVM_LOG_FUNC_ENTRY("avm_octet_string_2_entity_path");

   for (i = 0; i < SAHPI_MAX_ENTITY_PATH; i++ )
   {
      entity_path->Entry[i].EntityType    = 0;
#ifdef HPI_A
      entity_path->Entry[i].EntityInstance = 0; 
#else
      entity_path->Entry[i].EntityLocation = 0; 
#endif
   }

   for(i = 0; i <= length - 1;)
   {
      entity_type       = 0;
      entity_instance   = 0;
      found = 0;

      while((i <= length - 1) &&(!((ep[i] >= '0') && (ep[i] <= '9'))))
      {
         i++;
      }
      if(length == i)
      {
         return NCSCC_RC_SUCCESS;
      }

      while((i <= length -1 ) && ((ep[i] >= '0') && (ep[i] <= '9')))
      {
         found = 1;
         entity_type = entity_type*10 + (ep[i] - '0');
         i++;
      }
      if((found) && (length == i))
      {
         return NCSCC_RC_FAILURE;
      }
      
      while((i <= length -1 ) && (!((ep[i] >= '0') && (ep[i] <= '9'))))
      {
         i++;
      }

      found = 0;
      while((i <= length -1 ) && ((ep[i] >= '0') && (ep[i] <= '9')))
      {
         found  = 1;
         entity_instance = entity_instance*10 + (ep[i] - '0');
         i++;
      } 
      if(!found)
      {
         return NCSCC_RC_FAILURE;
      }

      if(entity_type)
      {
         entity_path->Entry[count].EntityType       = entity_type;
      }
      if(entity_instance)
      {
#ifdef HPI_A
         entity_path->Entry[count++].EntityInstance = entity_instance;
#else
         entity_path->Entry[count++].EntityLocation = entity_instance;
#endif
      }
   }

   return NCSCC_RC_SUCCESS;
}

/*****************************************************************************
 * Function: ncsavmentdeploytableentry_set
 *
 * Purpose:  This function is the set processing for objects in
 * NCSMIB_TBL_AVM_ENT_DEPLOYMENT table. This is the Deployed Entities table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function does the set of the object and the corresponding actions
 * for the objects that are settable. This same function can be used for test
 * operation also.
 *
 * Input:  cb        - AvM control block
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         var_info  - The VAR INFO structure pointer generated by MIBLIB for
 *                     the objects in this table.
 *         test_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: None.
 *
 * 
 *****************************************************************************/
EXTERN_C uns32
ncsavmentdeploytableentry_set(
                              NCSCONTEXT          cb,
                              NCSMIB_ARG         *arg,
                              NCSMIB_VAR_INFO    *var_info,
                              NCS_BOOL           test_flag
                             )
{
   AVM_CB_T          *avm_cb;
   AVM_ENT_INFO_T    *ent_info;
   AVM_EVT_T          fsm_evt;
   NCS_BOOL           ckpt_dhconf=FALSE, ckpt_dhstate=FALSE;
   uns8               logbuf[500];
   

   SaHpiEntityPathT   entity_path;

   AVM_ENT_PATH_STR_T ep;
   uns32     i;

   uns32 rc = NCSCC_RC_SUCCESS;
   
   avm_cb   = (AVM_CB_T*)cb;

   if(SA_AMF_HA_ACTIVE != avm_cb->ha_state)
   {
      m_AVM_LOG_INVALID_VAL_FATAL(avm_cb->ha_state);
      return NCSCC_RC_FAILURE;
   }
 
   avm_cb->config_cnt++;

   fsm_evt.evt.mib_req = arg;

   m_NCS_MEMSET(ep.name, '\0', AVM_MAX_INDEX_LEN);

   ep.length   = arg->i_idx.i_inst_ids[0];

   for(i = 0; i < ep.length; i++)
   {
      ep.name[i] = (uns8)(arg->i_idx.i_inst_ids[i + 1]);
   }

   ent_info = avm_find_ent_str_info(avm_cb, &ep,TRUE);

   if(AVM_ENT_INFO_NULL == ent_info) 
   {

      if((ncsAvmEntRowStatus_ID == arg->req.info.set_req.i_param_val.i_param_id) &&
         (NCS_ROW_CREATE_AND_WAIT != arg->req.info.set_req.i_param_val.i_param_id))
      {
         return NCSCC_RC_INV_VAL;
      }
   
      m_AVM_LOG_GEN_EP_STR("Octet String Received from extn world :", ep.name, NCSFL_SEV_INFO);

      rc = avm_octet_string_2_entity_path(ep.name, ep.length, &entity_path);

      if(NCSCC_RC_SUCCESS != rc)
      {
         return NCSCC_RC_INV_VAL;
      }

      if(TRUE == test_flag)
      {
         return NCSCC_RC_SUCCESS;
      }

      m_AVM_LOG_GEN("Entity Path Converted from String :", entity_path.Entry, sizeof(SaHpiEntityPathT), NCSFL_SEV_INFO);

      ent_info = avm_add_ent_info(avm_cb, &entity_path);
      if(AVM_ENT_INFO_NULL == ent_info)
      {
         return NCSCC_RC_NO_INSTANCE;
      }else
      {
      }    
      avm_add_ent_str_info(avm_cb, ent_info, &ep);
   }
   else /* ent_info != AVM_ENT_INFO_NULL */   
   {
      if(arg->req.info.set_req.i_param_val.i_param_id == ncsAvmEntRowStatus_ID)
      {
         if(arg->req.info.set_req.i_param_val.info.i_int == (uns32)(ent_info->row_status))
         {
            return NCSCC_RC_SUCCESS;      
         }

         switch(arg->req.info.set_req.i_param_val.info.i_int)
         {
            case NCS_ROW_ACTIVE:
            {
               
               if(TRUE == test_flag)
               {
                  return NCSCC_RC_SUCCESS;
               }

               ent_info->entity_type = ent_info->entity_path.Entry[0].EntityType;
               if(avm_cb->config_state == AVM_CONFIG_DONE)
               {
                  rc =  avm_check_dynamic_ent(avm_cb, ent_info);
                  if(NCSCC_RC_SUCCESS != rc)
                  {
                    return NCSCC_RC_INV_VAL;
                  }

                  m_AVM_SEND_CKPT_UPDT_ASYNC_ADD(avm_cb, ent_info, AVM_CKPT_ENT_CFG);
                 
                  if(ent_info->adm_lock)
                  
                  {   
                      fsm_evt.fsm_evt_type =  (arg->req.info.set_req.i_param_val.info.i_int + AVM_EVT_ADM_OP_BASE - 1);
                      avm_fsm_handler(avm_cb, ent_info, &fsm_evt);
                  }

                  m_AVM_LOG_GEN_EP_STR("Row made active now:", ent_info->ep_str.name, NCSFL_SEV_INFO);
               }else
               {
                  ent_info->row_status = NCS_ROW_ACTIVE;   
               }   
               return NCSCC_RC_SUCCESS;
            }
            break;

            case NCS_ROW_NOT_IN_SERVICE:
            {
               if(AVM_ENT_NOT_PRESENT != ent_info->current_state)
               {
                  m_AVM_LOG_GEN_EP_STR("Entity in Chassis", ent_info->ep_str.name, NCSFL_SEV_INFO);
                  return NCSCC_RC_INV_VAL;
               }

               if(AVM_ENT_INFO_LIST_NULL != ent_info->child)
               {
                  m_AVM_LOG_GEN_EP_STR("Child Entities Existing , Cant Make Row Status Not in Service", ent_info->ep_str.name, NCSFL_SEV_ERROR);
                  return NCSCC_RC_INV_VAL;
               }

               if(TRUE == test_flag)
               {
                  return NCSCC_RC_SUCCESS;
               }

               avm_deact_dependents(avm_cb, ent_info);               
               ent_info->row_status = NCS_ROW_NOT_IN_SERVICE;
              
               avm_rmv_ent_info(avm_cb, ent_info);

               m_AVM_SEND_CKPT_UPDT_ASYNC_RMV(avm_cb, ent_info, AVM_CKPT_ENT_CFG);
               return NCSCC_RC_SUCCESS;
            }
            break;

            case NCS_ROW_DESTROY:
            {
               if(NCS_ROW_ACTIVE == ent_info->row_status)
               {
                  return NCSCC_RC_INV_VAL;
               }
              
               if(TRUE == test_flag)
               {
                  return NCSCC_RC_SUCCESS;
               }

               m_AVM_SEND_CKPT_UPDT_ASYNC_RMV(avm_cb, ent_info, AVM_CKPT_ENT_CFG);
               avm_delete_ent_str_info(avm_cb, ent_info);
               avm_delete_ent_info(avm_cb, ent_info);
               ncshm_destroy_hdl(NCS_SERVICE_ID_AVM, ent_info->ent_hdl);
               m_MMGR_FREE_AVM_ENT_INFO(ent_info);
               return NCSCC_RC_SUCCESS;
            }
            break;

            default:
            {
               m_AVM_LOG_INVALID_VAL_ERROR(arg->req.info.set_req.i_param_val.info.i_int);
               return NCSCC_RC_INV_VAL;
            }
         }
      }   
   }
     
   if(TRUE == test_flag)
   {
      return NCSCC_RC_SUCCESS;
   }   

   if(((arg->req.info.set_req.i_param_val.i_param_id < ncsAvmEntNetBoot_ID) || 
       (arg->req.info.set_req.i_param_val.i_param_id > ncsAvmEntAdminOperCommit_ID)) &&
      (NCS_ROW_ACTIVE == ent_info->row_status))
   {
     if(avm_cb->config_state == AVM_CONFIG_NOT_DONE)
     {
         ent_info->adm_req = 0;
     }else
     { 
         switch(arg->req.info.set_req.i_param_val.i_param_id)
         {
            case ncsAvmEntAdmReq_ID:
            {
               if((AVM_ADM_SHUTDOWN > arg->req.info.set_req.i_param_val.info.i_int) ||
                  (AVM_ADM_UNLOCK  < arg->req.info.set_req.i_param_val.info.i_int))
               {
                  return NCSCC_RC_INV_VAL;
               }

               fsm_evt.fsm_evt_type =  (arg->req.info.set_req.i_param_val.info.i_int + AVM_EVT_ADM_OP_BASE - 1);
               rc = avm_fsm_handler(avm_cb, ent_info, &fsm_evt);
               m_AVM_SEND_CKPT_UPDT_ASYNC_ADD(avm_cb, ent_info, AVM_CKPT_ENT_ADM_OP);
               return rc;
            }
            break;

            case ncsAvmEntAdmReset_ID:
            {
               AVM_ENT_DHCP_CONF  *dhcp_conf;

               if((AVM_ADM_SOFT_RESET > arg->req.info.set_req.i_param_val.info.i_int) ||
                  (AVM_ADM_HARD_RESET < arg->req.info.set_req.i_param_val.info.i_int))
               {
                  return NCSCC_RC_INV_VAL;
               }

               fsm_evt.fsm_evt_type =  (arg->req.info.set_req.i_param_val.info.i_int + AVM_EVT_ADM_RESET_REQ_BASE - 1);

#if 0
               /* update the dhcp configuration here, before restarting the blade */
               dhcp_conf = &ent_info->dhcp_serv_conf;
               avm_ssu_dhconf(avm_cb, ent_info, NULL, 1);
#endif

               rc = avm_fsm_handler(avm_cb, ent_info, &fsm_evt);
               m_AVM_SEND_CKPT_UPDT_ASYNC_ADD(avm_cb, ent_info, AVM_CKPT_ENT_ADM_OP);

               /* Performing dhcp update after reset. Reason being reset might trigger rollback */
               /* which in turn would cause lock. That might cause reset operation to fail      */

               dhcp_conf = &ent_info->dhcp_serv_conf;
               avm_ssu_dhconf(avm_cb, ent_info, NULL, 1);

               return rc;
            }
            break;
         }

         if(AVM_ENT_NOT_PRESENT != ent_info->current_state)
         {
            m_AVM_LOG_GEN_EP_STR("Entity In Chassis, no Mib sets allowed", ent_info->ep_str.name, NCSFL_SEV_INFO);
            return NCSCC_RC_INV_VAL;
         }

          m_AVM_LOG_GEN_EP_STR("Row already active, no Mib sets allowed", ent_info->ep_str.name, NCSFL_SEV_INFO);
          return NCSCC_RC_INV_VAL;
      }
   }   

   switch(arg->req.info.set_req.i_param_val.i_param_id)
   {
      case ncsAvmEntIsNode_ID:
      {
         ent_info->is_node = (arg->req.info.set_req.i_param_val.info.i_int == NCS_SNMP_TRUE) ? TRUE : FALSE;     
      }
      break;

      case ncsAvmEntNodeName_ID:
      {
         m_NCS_MEMSET(ent_info->node_name.value, '\0', SA_MAX_NAME_LENGTH);

         ent_info->node_name.length = arg->req.info.set_req.i_param_val.i_length;
         m_NCS_MEMCPY(ent_info->node_name.value, arg->req.info.set_req.i_param_val.info.i_oct, ent_info->node_name.length);
      }
      break;

      case ncsAvmEntDependsOn_ID:
      {
         m_NCS_MEMSET(ent_info->dep_ep_str.name, '\0', AVM_MAX_INDEX_LEN);

         ent_info->dep_ep_str.length = arg->req.info.set_req.i_param_val.i_length;
      
         m_NCS_MEMCPY(ent_info->dep_ep_str.name, arg->req.info.set_req.i_param_val.info.i_oct, ent_info->dep_ep_str.length);
        
         if(ent_info->dep_ep_str.length)
         { 
           avm_octet_string_2_entity_path(ent_info->dep_ep_str.name, ent_info->dep_ep_str.length, &ent_info->depends_on); 
           ent_info->depends_on_valid = TRUE;
         }else
         {
           ent_info->depends_on_valid = FALSE;
         }
      }
      break;

      case ncsAvmEntAdmReset_ID:
      {
         m_AVM_LOG_GEN_EP_STR("Cant issue Adm Reset, Row not yet active", ent_info->ep_str.name, NCSFL_SEV_INFO);
         return NCSCC_RC_INV_VAL;
      }
      break;

      case ncsAvmEntAdmReq_ID:
      {
         if((AVM_ADM_SHUTDOWN == arg->req.info.set_req.i_param_val.info.i_int) || (AVM_ADM_LOCK == arg->req.info.set_req.i_param_val.info.i_int))
         {
            ent_info->adm_lock =  AVM_ADM_LOCK;
         }else if(arg->req.info.set_req.i_param_val.info.i_int == AVM_ADM_UNLOCK)
         {
            ent_info->adm_lock = AVM_ADM_UNLOCK;
         }
         return NCSCC_RC_SUCCESS;
      }
      break;

      case ncsAvmEntDescName_ID:
      {
         m_NCS_MEMSET(ent_info->desc_name.name, '\0', NCS_MAX_INDEX_LEN);

         ent_info->desc_name.length = arg->req.info.set_req.i_param_val.i_length;
         m_NCS_MEMCPY(ent_info->desc_name.name, arg->req.info.set_req.i_param_val.info.i_oct, ent_info->desc_name.length);
      }
      break;
      
      case ncsAvmEntParentDescName_ID:
      {
         m_NCS_MEMSET(ent_info->parent_desc_name.name, '\0', NCS_MAX_INDEX_LEN);

         ent_info->parent_desc_name.length = arg->req.info.set_req.i_param_val.i_length;
         m_NCS_MEMCPY(ent_info->parent_desc_name.name, arg->req.info.set_req.i_param_val.info.i_oct, ent_info->parent_desc_name.length);
      }
      break;
      
      case ncsAvmEntIsFru_ID:
      {
         ent_info->is_fru = (arg->req.info.set_req.i_param_val.info.i_int == NCS_SNMP_TRUE) ? TRUE : FALSE; 
      }
      break;     
      

      case ncsAvmEntIsActSrcNcs_ID:
      {
         if ((arg->req.info.set_req.i_param_val.info.i_int < AVM_SHELF_MGR_ACTIVATION) || 
             (arg->req.info.set_req.i_param_val.info.i_int >= AVM_MAX_ACT_POLICY_TYPE))
            goto failure;

         /* fill the source of activation and if validaiton required */
         ent_info->act_policy = arg->req.info.set_req.i_param_val.info.i_int;
      }
      break;

      case ncsAvmEntNetBoot_ID:
      {
         NCS_BOOL netboot_prev;

         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* if it is playback from pss just set it and don't act on it */
            ent_info->dhcp_serv_conf.net_boot = 
               arg->req.info.set_req.i_param_val.info.i_int;

            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntNetBoot_ID played back to: %d ",ent_info->ep_str.name,
                                                                                            ent_info->dhcp_serv_conf.net_boot);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);  

            ckpt_dhconf = TRUE; /* Check point it */
            break;
         }

         netboot_prev = ent_info->dhcp_serv_conf.net_boot;
         ent_info->dhcp_serv_conf.net_boot = 
            arg->req.info.set_req.i_param_val.info.i_int;

         ckpt_dhconf = TRUE;
         /* if netboot is moved from true to false then remove its DHCP configuration */
         if ((netboot_prev == NCS_SNMP_TRUE) && 
             (ent_info->dhcp_serv_conf.net_boot == NCS_SNMP_FALSE))
            avm_ssu_dhconf_set(avm_cb, &ent_info->dhcp_serv_conf, NULL, 1);
      }
      break;

      case ncsAvmEntAdminOperCommit_ID:
      {
#if 0 /* This object is obselete now */
         /* Set admin operation object and take corresponding actions */
         if (AVM_DHCP_COMMIT == arg->req.info.set_req.i_param_val.info.i_int)
         {
            /* TBD - JPL */
            if (SSU_COMMIT_PENDING == ent_info->dhcp_serv_conf.label1.status)
            {
               ent_info->dhcp_serv_conf.label1.status = SSU_COMMITTED;
               /* Push it into PSSV */
               m_AVM_SSU_PSSV_PUSH_INT(cb, ent_info->dhcp_serv_conf.label1.status, ncsAvmEntDHCPConfLabel1Status_ID, ent_info);

               ent_info->dhcp_serv_conf.default_chg = FALSE;
               ckpt_dhstate = TRUE;
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: %s's state SSU_COMMITTED",ent_info->ep_str.name,ent_info->dhcp_serv_conf.label1.name.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 
            }
            else if (SSU_COMMIT_PENDING == ent_info->dhcp_serv_conf.label2.status)
            {
               ent_info->dhcp_serv_conf.label2.status = SSU_COMMITTED;
               /* Push it into PSSV */
               m_AVM_SSU_PSSV_PUSH_INT(cb, ent_info->dhcp_serv_conf.label2.status, ncsAvmEntDHCPConfLabel2Status_ID, ent_info);

               ent_info->dhcp_serv_conf.default_chg = FALSE;
               ckpt_dhstate = TRUE;
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: %s's state SSU_COMMITTED",ent_info->ep_str.name,ent_info->dhcp_serv_conf.label2.name.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 
            }
            else
            {
               m_AVM_LOG_DEBUG("AVM-SSU: Can't COMMIT the LABEL, it is not in COMMIT_PENDING State", NCSFL_SEV_ERROR);
               goto failure;
            }
            /* Set default label and preferred label */
            ent_info->dhcp_serv_conf.default_label = ent_info->dhcp_serv_conf.curr_act_label;

            /* Set the preferred label also to other label */
            m_NCS_MEMSET(ent_info->dhcp_serv_conf.pref_label.name, '\0', AVM_NAME_STR_LENGTH);
            ent_info->dhcp_serv_conf.pref_label.length = ent_info->dhcp_serv_conf.default_label->name.length;
            m_NCS_MEMCPY(ent_info->dhcp_serv_conf.pref_label.name, ent_info->dhcp_serv_conf.default_label->name.name,
                ent_info->dhcp_serv_conf.pref_label.length);

            /* Push the preferred label into pssv */
            m_AVM_SSU_PSSV_PUSH_STR(cb, ent_info->dhcp_serv_conf.pref_label.name, ncsAvmEntDHCPConfPrefLabel_ID, ent_info, ent_info->dhcp_serv_conf.pref_label.length);

            ckpt_dhconf = TRUE;

            ent_info->dhcp_serv_conf.adm_oper = 
               arg->req.info.set_req.i_param_val.info.i_int;
         }
         else
         {
            m_AVM_LOG_DEBUG("AVM-SSU: Invalid Operation", NCSFL_SEV_ERROR);
            goto failure;
         }
#endif
      }
      break;

      case ncsAvmEntDHCPConfTFTPServerIp_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
            m_NCS_MEMCPY(ent_info->dhcp_serv_conf.tftp_serve_ip,
            arg->req.info.set_req.i_param_val.info.i_oct,4);

            ckpt_dhconf = TRUE; /* Checkpoint it */
            break;
         }

         /* If same Value, return Success */
         if (!m_NCS_MEMCMP(ent_info->dhcp_serv_conf.tftp_serve_ip,
            arg->req.info.set_req.i_param_val.info.i_oct,4))
            return NCSCC_RC_SUCCESS;

         m_NCS_MEMCPY(ent_info->dhcp_serv_conf.tftp_serve_ip,
            arg->req.info.set_req.i_param_val.info.i_oct,4);

         /* Check if any of the label is in no config, If yes then 
          * check whether we can change its state to INSTALL */
         if (SSU_NO_CONFIG == ent_info->dhcp_serv_conf.label1.status)
            avm_set_label_state_to_install(cb,ent_info,&ent_info->dhcp_serv_conf,
            &ent_info->dhcp_serv_conf.label1,LABEL1);
         if (ent_info->dhcp_serv_conf.label1.status == SSU_INSTALLED)
            ckpt_dhstate = TRUE;
         ent_info->dhcp_serv_conf.label1.conf_chg = TRUE;

         /* Do same for label 2 */
         if (SSU_NO_CONFIG == ent_info->dhcp_serv_conf.label2.status)
            avm_set_label_state_to_install(cb,ent_info,&ent_info->dhcp_serv_conf,
            &ent_info->dhcp_serv_conf.label2,LABEL2);
         if (ent_info->dhcp_serv_conf.label2.status == SSU_INSTALLED)
            ckpt_dhstate = TRUE;
         ent_info->dhcp_serv_conf.label2.conf_chg = TRUE;
      }
      break;

      case ncsAvmEntDHCPConfPrefLabel_ID:

      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
            /* First Check that the preferred label name is same as label 1
             * or label 2 name. Only then go ahead and set the preferred label
             */
            if (!AVM_DHCONF_MEMCMP_LEN(arg->req.info.set_req.i_param_val.info.i_oct, ent_info->dhcp_serv_conf.label1.name.name,
                                         ent_info->dhcp_serv_conf.label1.name.length, arg->req.info.set_req.i_param_val.i_length))
            {
               ent_info->dhcp_serv_conf.default_label = &ent_info->dhcp_serv_conf.label1;
               ent_info->dhcp_serv_conf.def_label_num = AVM_DEFAULT_LABEL_1;
               ent_info->dhcp_serv_conf.default_chg = TRUE;
            } 
            else if (!AVM_DHCONF_MEMCMP_LEN(arg->req.info.set_req.i_param_val.info.i_oct, ent_info->dhcp_serv_conf.label2.name.name,
                                   ent_info->dhcp_serv_conf.label2.name.length, arg->req.info.set_req.i_param_val.i_length))
            {
               ent_info->dhcp_serv_conf.default_label = &ent_info->dhcp_serv_conf.label2;
               ent_info->dhcp_serv_conf.def_label_num = AVM_DEFAULT_LABEL_2;
               ent_info->dhcp_serv_conf.default_chg = TRUE;
            }
            else
            {
               sysf_sprintf(logbuf, "AVM-SSU: Payload blade %s : ncsAvmEntDHCPConfPrefLabel_ID playback failed.. not matching to any label",
                                                     ent_info->ep_str.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);
               return NCSCC_RC_FAILURE;
            } 
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.pref_label,
                           arg->req.info.set_req.i_param_val);
            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfPrefLabel_ID played back to: %s ",ent_info->ep_str.name,
                                                                                       ent_info->dhcp_serv_conf.pref_label.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);
            /* Check point it */
            ckpt_dhconf = TRUE; 
            ckpt_dhstate = TRUE;

            /* Check if the current active label had played back*/   
            /* First Check that the current active label name is same as label 1
             * or label 2 name. Only then go ahead and set the current active label
             */
            if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.pss_curr_label.name, ent_info->dhcp_serv_conf.label1.name.name,
                                         ent_info->dhcp_serv_conf.label1.name.length, ent_info->dhcp_serv_conf.pss_curr_label.length))
            {
               ent_info->dhcp_serv_conf.curr_act_label = &ent_info->dhcp_serv_conf.label1;
               ent_info->dhcp_serv_conf.cur_act_label_num = AVM_CUR_ACTIVE_LABEL_1;
               m_AVM_LOG_DEBUG("curr_act_label set to Label1",NCSFL_SEV_NOTICE);
            } 
            else if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.pss_curr_label.name, ent_info->dhcp_serv_conf.label2.name.name,
                                   ent_info->dhcp_serv_conf.label2.name.length, ent_info->dhcp_serv_conf.pss_curr_label.length))
            {
               ent_info->dhcp_serv_conf.curr_act_label = &ent_info->dhcp_serv_conf.label2;
               ent_info->dhcp_serv_conf.cur_act_label_num = AVM_CUR_ACTIVE_LABEL_2;
               m_AVM_LOG_DEBUG("curr_act_label set to Label2",NCSFL_SEV_NOTICE);
            }
            else
            {
               sysf_sprintf(logbuf, "AVM-SSU: Payload blade %s : pss_curr_label:%s not matching to any label",
                                                     ent_info->ep_str.name,ent_info->dhcp_serv_conf.pss_curr_label.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);
            }

            break;
         }

         if (NCSCC_RC_SUCCESS != avm_set_preferred_label(avm_cb,ent_info,&ent_info->dhcp_serv_conf, 
            arg->req.info.set_req.i_param_val))
            goto failure;
         if (ent_info->dhcp_serv_conf.default_chg == TRUE)
         {
            ckpt_dhstate = TRUE;
            ckpt_dhconf = TRUE;
            sysf_sprintf(logbuf, "AVM-SSU: Payload blade %s : ncsAvmEntDHCPConfPrefLabel SET to: %s",
                                                     ent_info->ep_str.name,ent_info->dhcp_serv_conf.pref_label.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);
         }
      }
      break;

      case ncsAvmEntDHCPConfLabel1Name_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label1.name,
                        arg->req.info.set_req.i_param_val);

            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel1Name playedback to: %s ",
                                  ent_info->ep_str.name,ent_info->dhcp_serv_conf.label1.name.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

            ckpt_dhconf = TRUE; /* Check point it */
            break;
         }

         /* If same Value, return Success */
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.label1.name.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.label1.name.length,
            arg->req.info.set_req.i_param_val.i_length))
            return NCSCC_RC_SUCCESS;

         /* If value is same as other label then return Failure */
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.label2.name.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.label2.name.length,
            arg->req.info.set_req.i_param_val.i_length))
         {
               m_AVM_LOG_DEBUG("AVM-SSU: Label with the same name already exists", NCSFL_SEV_ERROR);
               goto failure;
         }
#if 0
         /* The change is for current Active label then return Failure. */
         if ((&ent_info->dhcp_serv_conf.label1 == 
            ent_info->dhcp_serv_conf.curr_act_label) ||
             (ent_info->dhcp_serv_conf.label2.status == SSU_COMMIT_PENDING))
         {
            m_AVM_LOG_DEBUG("AVM-SSU: Active label name can't be changed", NCSFL_SEV_ERROR);
            goto failure;
         }
#endif
         if ( FALSE == avm_validate_state_for_dhcp_conf_change(ent_info, &ent_info->dhcp_serv_conf.label1, &ent_info->dhcp_serv_conf.label2))
            goto failure; 

         /* Fix for IR00084622 */
         if((0 != ent_info->dhcp_serv_conf.pref_label.length) &&
            (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.pref_label.name, ent_info->dhcp_serv_conf.label1.name.name,
                              ent_info->dhcp_serv_conf.label1.name.length, ent_info->dhcp_serv_conf.pref_label.length)))
         { 
            m_NCS_MEMSET(ent_info->dhcp_serv_conf.pref_label.name, '\0', AVM_NAME_STR_LENGTH);
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.pref_label, 
                           arg->req.info.set_req.i_param_val);

            /* Push the preferred label into pssv */
            m_AVM_SSU_PSSV_PUSH_STR(cb, ent_info->dhcp_serv_conf.pref_label.name, ncsAvmEntDHCPConfPrefLabel_ID, ent_info, ent_info->dhcp_serv_conf.pref_label.length);
         }

         m_NCS_MEMSET(ent_info->dhcp_serv_conf.label1.name.name, '\0', AVM_NAME_STR_LENGTH);
         /* Copy the name */
         m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label1.name, 
                        arg->req.info.set_req.i_param_val);

         ckpt_dhconf = TRUE;
         sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel1Name SET to %s",
                               ent_info->ep_str.name,ent_info->dhcp_serv_conf.label1.name.name);
         m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

         /* Find-out whether we can change the state to 
          * INSTALLED with this set. If we can set to INSTALLED then 
          * change the state to INSTALLED */
         avm_set_label_state_to_install(cb,ent_info,&ent_info->dhcp_serv_conf,
            &ent_info->dhcp_serv_conf.label1,LABEL1);
         if (ent_info->dhcp_serv_conf.label1.status == SSU_INSTALLED)
            ckpt_dhstate = TRUE;
      }
      break;

      case ncsAvmEntDHCPConfFileNameLabel1_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label1.file_name,
                        arg->req.info.set_req.i_param_val);
            
            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfFileNameLabel1 played back to: %s ",
                                 ent_info->ep_str.name,ent_info->dhcp_serv_conf.label1.file_name.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

            ckpt_dhconf = TRUE; /* Check point it */
            break;
         }

         /* If same Value, return Success */
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.label1.file_name.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.label1.file_name.length,
            arg->req.info.set_req.i_param_val.i_length))
            return NCSCC_RC_SUCCESS;
#if 0
         /* The change is for current Active label then return Failure. */
         if ((&ent_info->dhcp_serv_conf.label1 == 
            ent_info->dhcp_serv_conf.curr_act_label) ||
             (ent_info->dhcp_serv_conf.label2.status == SSU_COMMIT_PENDING))
         {
            m_AVM_LOG_DEBUG("AVM-SSU: Active label Conf File Name can't be changed", NCSFL_SEV_ERROR);
            goto failure;
         }
#endif
         if ( FALSE == avm_validate_state_for_dhcp_conf_change(ent_info, &ent_info->dhcp_serv_conf.label1, &ent_info->dhcp_serv_conf.label2))
            goto failure;
 
         /* Validate the installtion contents and set version of file */
         
         if (NCSCC_RC_SUCCESS != avm_dhcp_file_validation(cb,ent_info,arg->req.info.set_req.i_param_val,
                                  &ent_info->dhcp_serv_conf.label1, LABEL1))
         {
            m_AVM_LOG_DEBUG("File name validation failure", NCSFL_SEV_ERROR);
            goto failure;
         }

          m_NCS_MEMSET(ent_info->dhcp_serv_conf.label1.file_name.name, '\0', AVM_NAME_STR_LENGTH); 
         /* Copy the file name */
         m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label1.file_name,
            arg->req.info.set_req.i_param_val);
         ckpt_dhconf = TRUE;
         sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfFileNameLabel1 SET to %s",
                              ent_info->ep_str.name,ent_info->dhcp_serv_conf.label1.file_name.name);
         m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

         /* Find-out whether we can change the state to 
          * INSTALLED with this set. If we can set to INSTALLED then 
          * change the state to INSTALLED */
         avm_set_label_state_to_install(cb,ent_info,&ent_info->dhcp_serv_conf,
            &ent_info->dhcp_serv_conf.label1,LABEL1);
         if (ent_info->dhcp_serv_conf.label1.status == SSU_INSTALLED)
            ckpt_dhstate = TRUE;

         ent_info->dhcp_serv_conf.label1.conf_chg = TRUE;

      }
      break;

      case ncsAvmEntDHCPConfLabel2Name_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label2.name,
                        arg->req.info.set_req.i_param_val);

            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel2Name played back to: %s ",
                              ent_info->ep_str.name,ent_info->dhcp_serv_conf.label2.name.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

            ckpt_dhconf = TRUE; /* Check point it */
            break;
         }

         /* If same Value, return Success*/
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.label2.name.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.label2.name.length,
            arg->req.info.set_req.i_param_val.i_length))
            return NCSCC_RC_SUCCESS;

         /* If value is same as other label then return failure */
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.label1.name.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.label1.name.length,
            arg->req.info.set_req.i_param_val.i_length))
         {
            m_AVM_LOG_DEBUG("AVM-SSU: Label with the same name already exists", NCSFL_SEV_ERROR);
            goto failure;
         }

#if 0
         /* The change is for current Active label then return Failure. */
         if ((&ent_info->dhcp_serv_conf.label2 == 
            ent_info->dhcp_serv_conf.curr_act_label) ||
             (ent_info->dhcp_serv_conf.label1.status == SSU_COMMIT_PENDING))
         { 
            m_AVM_LOG_DEBUG("AVM-SSU: Active label name can't be changed", NCSFL_SEV_ERROR);
            goto failure;
         }
#endif

/* vivek_ut */
/* Should be reversed */
         if ( FALSE == avm_validate_state_for_dhcp_conf_change(ent_info, &ent_info->dhcp_serv_conf.label2, &ent_info->dhcp_serv_conf.label1))
            goto failure;
#if 0
         if ( FALSE == avm_validate_state_for_dhcp_conf_change(ent_info, &ent_info->dhcp_serv_conf.label1, &ent_info->dhcp_serv_conf.label2))
            goto failure;
#endif

         /* Fix for IR00084622 */
         if((0 != ent_info->dhcp_serv_conf.pref_label.length) &&
            (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.pref_label.name, ent_info->dhcp_serv_conf.label2.name.name,
                              ent_info->dhcp_serv_conf.label2.name.length, ent_info->dhcp_serv_conf.pref_label.length)))
         { 
            m_NCS_MEMSET(ent_info->dhcp_serv_conf.pref_label.name, '\0', AVM_NAME_STR_LENGTH);
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.pref_label, 
                           arg->req.info.set_req.i_param_val);
            
            /* Push the preferred label into pssv */
            m_AVM_SSU_PSSV_PUSH_STR(cb, ent_info->dhcp_serv_conf.pref_label.name, ncsAvmEntDHCPConfPrefLabel_ID, ent_info, ent_info->dhcp_serv_conf.pref_label.length);
         }

         m_NCS_MEMSET(ent_info->dhcp_serv_conf.label2.name.name, '\0', AVM_NAME_STR_LENGTH);
         /* Copy the name */
         m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label2.name,
            arg->req.info.set_req.i_param_val);
         ckpt_dhconf = TRUE;
         sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel2Name SET to %s",
                              ent_info->ep_str.name,ent_info->dhcp_serv_conf.label2.name.name);
         m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

         /* Find-out whether we can change the state to 
          * INSTALLED with this set. If we can set to INSTALLED then 
          * change the state to INSTALLED */
         avm_set_label_state_to_install(cb,ent_info,&ent_info->dhcp_serv_conf,
            &ent_info->dhcp_serv_conf.label2,LABEL2);
         if (ent_info->dhcp_serv_conf.label2.status == SSU_INSTALLED)
            ckpt_dhstate = TRUE;
      }
      break;

      case ncsAvmEntDHCPConfFileNameLabel2_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label2.file_name,
                        arg->req.info.set_req.i_param_val);

            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfFileNameLabel2 played back to: %s ",
                                 ent_info->ep_str.name,ent_info->dhcp_serv_conf.label2.file_name.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

            ckpt_dhconf = TRUE; /* Check point it */
            break;
         }

         /* If same Value, return Success */
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.label2.file_name.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.label2.file_name.length,
            arg->req.info.set_req.i_param_val.i_length))
            return NCSCC_RC_SUCCESS;

#if 0
         /* The change is for current Active label then return Failure. */
         if ((&ent_info->dhcp_serv_conf.label2 == 
            ent_info->dhcp_serv_conf.curr_act_label) ||
             (ent_info->dhcp_serv_conf.label1.status == SSU_COMMIT_PENDING))
         {
            m_AVM_LOG_DEBUG("AVM-SSU: Active label Conf File Name can't be changed", NCSFL_SEV_ERROR);
            goto failure;
         }
#endif

/* vivek_ut */
/* Should be reversed */
         if ( FALSE == avm_validate_state_for_dhcp_conf_change(ent_info, &ent_info->dhcp_serv_conf.label2, &ent_info->dhcp_serv_conf.label1))
            goto failure;
#if 0
         if ( FALSE == avm_validate_state_for_dhcp_conf_change(ent_info, &ent_info->dhcp_serv_conf.label1, &ent_info->dhcp_serv_conf.label2))
            goto failure;
#endif

         /* Validate the installtion contents and set version of file */
         
         if (NCSCC_RC_SUCCESS != avm_dhcp_file_validation(cb,ent_info,arg->req.info.set_req.i_param_val,
                                  &ent_info->dhcp_serv_conf.label2, LABEL2))
            goto failure;

         m_NCS_MEMSET(ent_info->dhcp_serv_conf.label2.file_name.name, '\0', AVM_NAME_STR_LENGTH);
         /* Copy the file name */
         m_AVM_SET_NAME(ent_info->dhcp_serv_conf.label2.file_name,
            arg->req.info.set_req.i_param_val);
         ckpt_dhconf = TRUE;
         sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfFileNameLabel2 SET to %s",
                              ent_info->ep_str.name,ent_info->dhcp_serv_conf.label2.file_name.name);
         m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

         /* Find-out whether we can change the state to 
          * INSTALLED with this set. If we can set to INSTALLED then 
          * change the state to INSTALLED */
         avm_set_label_state_to_install(cb,ent_info,&ent_info->dhcp_serv_conf,
            &ent_info->dhcp_serv_conf.label2,LABEL2);
         if (ent_info->dhcp_serv_conf.label2.status == SSU_INSTALLED)
            ckpt_dhstate = TRUE;
         ent_info->dhcp_serv_conf.label2.conf_chg = TRUE;

      }
      break;
      
      case ncsAvmEntDHCPConfLabel1Status_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            ent_info->dhcp_serv_conf.label1.status = arg->req.info.set_req.i_param_val.info.i_int;
            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel1Status_ID played back to: %d ",ent_info->ep_str.name,
                                                          ent_info->dhcp_serv_conf.label1.status);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 

            ckpt_dhstate = TRUE; /* CHeck point it */
         }
      } 
      break;
  
      case ncsAvmEntDHCPConfLabel2Status_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            ent_info->dhcp_serv_conf.label2.status = arg->req.info.set_req.i_param_val.info.i_int;
            sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel2Status_ID played back to: %d ",ent_info->ep_str.name,
                                                            ent_info->dhcp_serv_conf.label2.status);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);  

            ckpt_dhstate = TRUE; /* CHeck point it */
         }
      }  
      break;

      case ncsAvmEntDHCPConfInstallTimeLabel1_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
           m_NCS_MEMCPY(ent_info->dhcp_serv_conf.label1.install_time.install_time,arg->req.info.set_req.i_param_val.info.i_oct,8);
           
           /* Checkpoint it */
           ckpt_dhconf = TRUE;
         }
      }
      break;

      case ncsAvmEntDHCPConfLabel1SwVersion_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */  
           ent_info->dhcp_serv_conf.label1.sw_version.length = arg->req.info.set_req.i_param_val.i_length;  
           m_NCS_MEMCPY(ent_info->dhcp_serv_conf.label1.sw_version.name,arg->req.info.set_req.i_param_val.info.i_oct,
                                                                     ent_info->dhcp_serv_conf.label1.sw_version.length);

           sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel1SwVersion_ID played back to: %s ",ent_info->ep_str.name,
                                                            ent_info->dhcp_serv_conf.label1.sw_version.name);
           m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 
 
           /* Checkpoint it */
           ckpt_dhconf = TRUE;
         }
      }
      break;

      case ncsAvmEntDHCPConfInstallTimeLabel2_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */   
           m_NCS_MEMCPY(ent_info->dhcp_serv_conf.label2.install_time.install_time,arg->req.info.set_req.i_param_val.info.i_oct,8);
           
           /* Checkpoint it */
           ckpt_dhconf = TRUE;
         }
      }
      break;

      case ncsAvmEntDHCPConfLabel2SwVersion_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /* If it is playback from PSS, just store it. Don't act on it  */  
           ent_info->dhcp_serv_conf.label2.sw_version.length = arg->req.info.set_req.i_param_val.i_length;  
           m_NCS_MEMCPY(ent_info->dhcp_serv_conf.label2.sw_version.name,arg->req.info.set_req.i_param_val.info.i_oct,
                                                                     ent_info->dhcp_serv_conf.label2.sw_version.length);

           sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntDHCPConfLabel2SwVersion_ID played back to: %s ",ent_info->ep_str.name,
                                                            ent_info->dhcp_serv_conf.label2.sw_version.name);
           m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 

           /* Checkpoint it */
           ckpt_dhconf = TRUE;
         }
      }
      break;

      case ncsAvmEntDHCPConfCurrActiveLabel_ID:
      {
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            /*****************************************************************************************
                 When the current active label gets played back, the label1 and label2 won't be 
                 available in the database. So store the current active label name in a temporary 
                 variable pss_curr_label, and set the current active label when the preferred label 
                 gets playedback 
            *****************************************************************************************/    
            m_NCS_MEMSET(ent_info->dhcp_serv_conf.label2.file_name.name, '\0', AVM_NAME_STR_LENGTH);
            m_AVM_SET_NAME(ent_info->dhcp_serv_conf.pss_curr_label,arg->req.info.set_req.i_param_val);
         }
      }
      break; 

      default:
      {
         goto failure;
      }
   }    
   /* async update */
   if (ckpt_dhconf == TRUE)
      m_AVM_SEND_CKPT_UPDT_ASYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_DHCP_CONF_CHG);
   if (ckpt_dhstate == TRUE)
      m_AVM_SEND_CKPT_UPDT_ASYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_DHCP_STATE_CHG);

   return NCSCC_RC_SUCCESS;

failure:
   m_AVM_LOG_INVALID_VAL_ERROR(arg->req.info.set_req.i_param_val.i_param_id);
   return NCSCC_RC_FAILURE;
}

/*****************************************************************************
 * Function: ncsavmentdeploytableentry_extract
 *
 * Purpose:  This function is one of the get processing function for objects in
 * NCSMIB_TBL_AVM_ENT_DEPLOYMENT table.The  name of this function is 
 * generated by the MIBLIB tool. This function
 * will be called by MIBLIB after calling the get call to get data structure.
 * This function fills the value information in the param filed structure. For
 * octate information the buffer field will be used for filling the information.
 * MIBLIB will provide the memory and pointer to the buffer. For only objects that
 * have a direct value(i.e their offset is not 0 in VAR INFO) in the structure
 * the data field is filled using the VAR INFO provided by MIBLIB, for others based
 * on the OID the value is filled accordingly.
 *
 * Input:  param     -  param->i_param_id indicates the parameter to extract
 *                      The remaining elements of the param need to be filled
 *                      by the subystem's extract function
 *         var_info  - Pointer to the var_info structure for the param.
 *         data      - The pointer to the data-structure containing the object
 *                     value which we have already provided to MIBLIB from get call.
 *         buffer    - The buffer pointer provided by MIBLIB for filling the octate
 *                     type data.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 *
 * NOTES:  This function works in conjunction with other functions to provide the
 * get,getnext and getrow functionality.
 *
 * 
 **************************************************************************/
EXTERN_C uns32
ncsavmentdeploytableentry_extract(
                                   NCSMIB_PARAM_VAL *param,
                                   NCSMIB_VAR_INFO  *var_info,
                                   NCSCONTEXT data,
                                   NCSCONTEXT buffer
                                 )
{  
   AVM_ENT_INFO_T *ent_info = (AVM_ENT_INFO_T*) data;

   m_AVM_LOG_FUNC_ENTRY("ncsavmentdeploytableentry_extract");   
   
   if(AVM_ENT_INFO_NULL == ent_info)
   {
      m_AVM_LOG_DEBUG("\n Row Not Found",NCSFL_SEV_ERROR);
      return NCSCC_RC_NO_INSTANCE;
   }

   switch(param->i_param_id)
   {
      case ncsAvmEntPath_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;

         param->i_length  = m_NCS_OS_NTOHS(ent_info->ep_str.length);
         m_NCS_MEMCPY((uns8*)buffer, ent_info->ep_str.name, param->i_length);
         param->info.i_oct     = (uns8*)buffer;  
      }
      break;   

      case ncsAvmEntIsNode_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = (ent_info->is_node == TRUE)? NCS_SNMP_TRUE : NCS_SNMP_FALSE;
      }
      break;

      case ncsAvmEntNodeName_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->node_name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->node_name.value, param->i_length);
         param->info.i_oct     = (uns8*)buffer;  
      }
      break;

      case ncsAvmEntProductName_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = 0;
         if(ent_info->valid_info)
         {
            param->i_fmat_id = NCSMIB_FMAT_OCT;
            param->i_length  = ent_info->valid_info->inv_data.product_name.DataLength;
            m_NCS_MEMCPY((uns8*)buffer, ent_info->valid_info->inv_data.product_name.Data, param->i_length);
            param->info.i_oct     = (uns8*)buffer;  
         }
         
         
      }
      break;

      case ncsAvmEntProductVer_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = 0;
         if(AVM_VALID_INFO_NULL != ent_info->valid_info)
         { 
            param->i_length  = ent_info->valid_info->inv_data.product_version.DataLength;
            m_NCS_MEMCPY((uns8*)buffer, ent_info->valid_info->inv_data.product_version.Data, param->i_length);
            param->info.i_oct     = (uns8*)buffer;  
         } 
      }
      break;

      case ncsAvmEntDependsOn_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = 0;
         
         if(ent_info->depends_on_valid == TRUE)
         {
            param->i_length  = ent_info->dep_ep_str.length;
            m_NCS_MEMCPY((uns8*)buffer, ent_info->dep_ep_str.name, param->i_length);
            param->info.i_oct     = (uns8*)buffer;  
         }
      }
      break;

      case ncsAvmEntAdmReset_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = (ent_info->current_state == AVM_ENT_RESET_REQ)? 1 : 0;
      }
      break;

      case ncsAvmEntAdmReq_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         if((AVM_ADM_LOCK == ent_info->adm_lock) || (ent_info->adm_shutdown))
         {
            param->info.i_int =  AVM_ADM_LOCK;
         }else
         {
            param->info.i_int =  AVM_ADM_UNLOCK;
         }
      }
      break;

      case ncsAvmEntDescName_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->desc_name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->desc_name.name, param->i_length);
         param->info.i_oct     = (uns8*)buffer;  
      }
      break;
      
      case ncsAvmEntParentDescName_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->parent_desc_name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->parent_desc_name.name, param->i_length);
         param->info.i_oct     = (uns8*)buffer;  
      }
      break;

      case ncsAvmEntIsFru_ID:
      {
         param->i_fmat_id    = NCSMIB_FMAT_INT;
         param->i_length     = 1;
         param->info.i_int   = (ent_info->is_fru == TRUE)? NCS_SNMP_TRUE : NCS_SNMP_FALSE;
      }  
      break;

      case ncsAvmEntIsActSrcNcs_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_INT;
         param->i_length  = 1;
         param->info.i_int  = ent_info->act_policy;  
      }
      break;
      
      case ncsAvmEntHWState_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length     = 1; 

         if(AVM_ENT_RESET_REQ == ent_info->current_state)
         {
            param->info.i_int = AVM_ENT_ACTIVE;
         }else
         if(AVM_ENT_EXTRACT_REQ == ent_info->current_state)
         {
            param->info.i_int = 4;
         }else
         {
            param->info.i_int = ent_info->current_state;
         }
      }
      break;

      case ncsAvmEntNetBoot_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = ent_info->dhcp_serv_conf.net_boot;
      }
      break;

      case ncsAvmEntAdminOperCommit_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = ent_info->dhcp_serv_conf.adm_oper;
      }
      break;

      case ncsAvmEntDHCPConfTFTPServerIp_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = 4;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.tftp_serve_ip, 4);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfPrefLabel_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.pref_label.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.pref_label.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfCurrActiveLabel_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         if (NULL != ent_info->dhcp_serv_conf.curr_act_label)
         {
            param->i_length  = ent_info->dhcp_serv_conf.curr_act_label->name.length;
            m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.curr_act_label->name.name, param->i_length);
         }
         else
            param->i_length  = 0;
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfLabel1Name_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.label1.name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label1.name.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfFileNameLabel1_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.label1.file_name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label1.file_name.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfLabel1Status_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;

         /* Send the Status as validated, if status is commtted and is
          * not an active label */
         if ((ent_info->dhcp_serv_conf.label1.status == SSU_COMMITTED) &&
             (ent_info->dhcp_serv_conf.label2.status == SSU_COMMITTED) &&  
             (ent_info->dhcp_serv_conf.curr_act_label != 
              &ent_info->dhcp_serv_conf.label1))
         {
            param->info.i_int = SSU_VALIDATED;
         }
         else
            param->info.i_int = ent_info->dhcp_serv_conf.label1.status;
      }
      break;

      case ncsAvmEntDHCPConfInstallTimeLabel1_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = 8;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label1.install_time.install_time, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfLabel1SwVersion_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.label1.sw_version.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label1.sw_version.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfLabel2Name_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.label2.name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label2.name.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfFileNameLabel2_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.label2.file_name.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label2.file_name.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfLabel2Status_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         /* Send the Status as validated, if status is commtted and is
          * not an active label */
         if ((ent_info->dhcp_serv_conf.label2.status == SSU_COMMITTED) &&
             (ent_info->dhcp_serv_conf.label1.status == SSU_COMMITTED) &&
             (ent_info->dhcp_serv_conf.curr_act_label !=
              &ent_info->dhcp_serv_conf.label2))
         {
            param->info.i_int = SSU_VALIDATED;
         }
         else
            param->info.i_int = ent_info->dhcp_serv_conf.label2.status;
      }
      break;

      case ncsAvmEntDHCPConfInstallTimeLabel2_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = 8;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label2.install_time.install_time, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntDHCPConfLabel2SwVersion_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.label2.sw_version.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.label2.sw_version.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;

      case ncsAvmEntRowStatus_ID: 
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = ent_info->row_status;
      }
      break;

      default:
      {
         m_AVM_LOG_DEBUG("Invalid Param Id Passed", NCSFL_SEV_CRITICAL);
         return NCSCC_RC_FAILURE;
      }
   }
   return NCSCC_RC_SUCCESS;
}

/*****************************************************************************
 * Function: ncsavmentdeploytableentry_get
 *
 * Purpose:  This function is one of the get processing routines for objects
 * in NCSMIB_TBL_AVM_ENT_DEPLOYMENT table. 
 * The name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function finds the corresponding data structure for the given
 * instance and returns the pointer to the structure.
 *
 * Input:  cb        - AVD control block.
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 * NOTES: This function works in conjunction with extract function to provide the
 * get functionality.
 *
 * 
 **************************************************************************/
EXTERN_C uns32
ncsavmentdeploytableentry_get(
                               NCSCONTEXT  cb,
                               NCSMIB_ARG  *arg,
                               NCSCONTEXT  *data
                            )
{
  
   AVM_CB_T            *avm_cb;
   AVM_ENT_INFO_T      *ent_info;
   AVM_ENT_PATH_STR_T   ep_str;      

   uns8      i;

   m_AVM_LOG_FUNC_ENTRY("ncsavmentdeploytableentry_get");
   
   avm_cb   = (AVM_CB_T*)cb;

   m_NCS_MEMSET(ep_str.name, '\0', AVM_MAX_INDEX_LEN);

   ep_str.length   = arg->i_idx.i_inst_ids[0];
   for(i = 0; i < ep_str.length; i++)
   {
      ep_str.name[i] = (uns8)(arg->i_idx.i_inst_ids[i + 1]);
   }

   ent_info = avm_find_ent_str_info(avm_cb, &ep_str,TRUE);

   if(AVM_ENT_INFO_NULL == ent_info)
   {
      return NCSCC_RC_NO_INSTANCE;
   }   

   *data = (NCSCONTEXT)ent_info;
   
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmentdeploytableentry_next(
                                 NCSCONTEXT   cb,
                                 NCSMIB_ARG  *arg,
                                 NCSCONTEXT  *data,
                                 uns32       *next_inst_id,
                                 uns32       *next_inst_id_len
                              )
{
   AVM_CB_T           *avm_cb = (AVM_CB_T*)cb;
   AVM_ENT_INFO_T     *ent_info;
   AVM_ENT_PATH_STR_T  ep_str;      
   uns32               i;

   m_AVM_LOG_FUNC_ENTRY("ncsavmentdeploytableentry_next");

   m_NCS_MEMSET(ep_str.name, '\0', AVM_MAX_INDEX_LEN);

   if(arg->i_idx.i_inst_len  != 0)
   {
      ep_str.length   = arg->i_idx.i_inst_ids[0];
      for(i = 0; i < ep_str.length; i++)
      {
         ep_str.name[i] = (uns8)(arg->i_idx.i_inst_ids[i + 1]);
      }
   }else
   {
      ep_str.length = 0;
      ent_info = avm_find_next_ent_str_info(avm_cb, &ep_str);
      if(AVM_ENT_INFO_NULL == ent_info)
      {
         return NCSCC_RC_NO_INSTANCE;   
      } 
      
      ep_str.length = m_NCS_OS_NTOHS(ent_info->ep_str.length);
      m_NCS_MEMCPY(ep_str.name, ent_info->ep_str.name, ep_str.length);
   }
  
   ent_info = avm_find_next_ent_str_info(avm_cb, &ep_str);
   if(AVM_ENT_INFO_NULL == ent_info) 
   {
      return NCSCC_RC_NO_INSTANCE;   
   }
      
   /* Fill next instance index */

   *next_inst_id_len = m_NCS_OS_NTOHS(ent_info->ep_str.length) + 1; 

    next_inst_id[0]  = *next_inst_id_len - 1;
    
    for(i = 0; i < next_inst_id[0]; i++)
    {
       next_inst_id[i + 1] = (uns32)(ent_info->ep_str.name[i]);   
    }      
    
    (*data) = (NCSCONTEXT) ent_info;

    return NCSCC_RC_SUCCESS;   
}

EXTERN_C uns32
ncsavmentdeploytableentry_setrow(
                                 NCSCONTEXT               cb,
                                 NCSMIB_ARG              *args,
                                 NCSMIB_SETROW_PARAM_VAL *params,
                                 struct ncsmib_obj_info  *obj_info,
                                 NCS_BOOL                 testrow_flag
                               )
{
   return NCSCC_RC_SUCCESS;
}


EXTERN_C uns32
ncsavmentfaultdomaintableentry_get(
                                  NCSCONTEXT  cb,
                                  NCSMIB_ARG  *arg,
                                  NCSCONTEXT  *data
                                 )
{
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmentfaultdomaintableentry_extract(
                                       NCSMIB_PARAM_VAL *param,
                                       NCSMIB_VAR_INFO  *var_info,
                                       NCSCONTEXT data,
                                       NCSCONTEXT buffer
                                     )
{
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmentfaultdomaintableentry_set(
                                   NCSCONTEXT          cb,
                                   NCSMIB_ARG         *arg,
                                   NCSMIB_VAR_INFO    *var_info,

                                    NCS_BOOL           test_flag
                                  )
{
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmentfaultdomaintableentry_next(
                                     NCSCONTEXT   cb,
                                     NCSMIB_ARG  *arg,
                                     NCSCONTEXT  *data,
                                     uns32       *next_inst_id,
                                     uns32       *next_inst_id_len
                                    ) 
{
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmentfaultdomaintableentry_setrow(
                                 NCSCONTEXT               cb,
                                 NCSMIB_ARG              *args,
                                 NCSMIB_SETROW_PARAM_VAL *params,
                                 struct ncsmib_obj_info  *obj_info,
                                 NCS_BOOL                 testrow_flag
                                      )
{
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmsupporttableentry_get(
                               NCSCONTEXT  cb,
                               NCSMIB_ARG  *arg,
                               NCSCONTEXT  *data
                             )
{
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmsupporttableentry_extract(
                                   NCSMIB_PARAM_VAL *param,
                                   NCSMIB_VAR_INFO  *var_info, 
                                   NCSCONTEXT data,
                                   NCSCONTEXT buffer
                                 )
{
   return NCSCC_RC_SUCCESS;
}
EXTERN_C uns32 
ncsavmsupporttableentry_set(
                              NCSCONTEXT          cb,
                              NCSMIB_ARG         *arg,
                              NCSMIB_VAR_INFO    *var_info,
                              NCS_BOOL           test_flag
                            )
{
   return NCSCC_RC_SUCCESS;
}
EXTERN_C uns32
ncsavmsupporttableentry_next(
                                 NCSCONTEXT   cb,
                                 NCSMIB_ARG  *arg,
                                 NCSCONTEXT  *data,
                                 uns32       *next_inst_id,
                                 uns32       *next_inst_id_len
                              )
{
   return NCSCC_RC_SUCCESS;
}
EXTERN_C uns32
ncsavmsupporttableentry_setrow(
                                 NCSCONTEXT               cb,
                                 NCSMIB_ARG              *args,
                                 NCSMIB_SETROW_PARAM_VAL *params,
                                 struct ncsmib_obj_info  *obj_info,
                                 NCS_BOOL                 testrow_flag
                               ) 
{
   return NCSCC_RC_SUCCESS;
}
EXTERN_C uns32 
ncsavmentupgradetableentry_set(
                              NCSCONTEXT          cb,
                              NCSMIB_ARG         *arg,
                              NCSMIB_VAR_INFO    *var_info,
                              NCS_BOOL           test_flag
                            )
{
   AVM_CB_T          *avm_cb;
   AVM_ENT_INFO_T    *ent_info;
   NCS_BOOL           ckpt_dhconf=FALSE, ckpt_dhstate=FALSE, ckpt_upgd_state=TRUE;
   uns8               logbuf[AVM_LOG_STR_MAX_LEN];
   

   SaHpiEntityPathT   entity_path;

   AVM_ENT_PATH_STR_T ep;
   uns32     i;

   uns32 rc = NCSCC_RC_SUCCESS;
   
   avm_cb   = (AVM_CB_T*)cb;

   if(SA_AMF_HA_ACTIVE != avm_cb->ha_state)
   {
      m_AVM_LOG_INVALID_VAL_FATAL(avm_cb->ha_state);
      return NCSCC_RC_FAILURE;
   }
 
   avm_cb->config_cnt++;

   m_NCS_MEMSET(ep.name, '\0', AVM_MAX_INDEX_LEN);

   ep.length   = arg->i_idx.i_inst_ids[0];

   for(i = 0; i < ep.length; i++)
   {
      ep.name[i] = (uns8)(arg->i_idx.i_inst_ids[i + 1]);
   }

   ent_info = avm_find_ent_str_info(avm_cb, &ep,TRUE);

   if(AVM_ENT_INFO_NULL == ent_info) 
   {

      m_AVM_LOG_GEN_EP_STR("Octet String Received from extn world :", ep.name, NCSFL_SEV_INFO);

      rc = avm_octet_string_2_entity_path(ep.name, ep.length, &entity_path);

      if(NCSCC_RC_SUCCESS != rc)
      {
         return NCSCC_RC_INV_VAL;
      }

      if(TRUE == test_flag)
      {
         return NCSCC_RC_SUCCESS;
      }

      m_AVM_LOG_GEN("Entity Path Converted from String :", entity_path.Entry, sizeof(SaHpiEntityPathT), NCSFL_SEV_INFO);

      ent_info = avm_add_ent_info(avm_cb, &entity_path);
      if(AVM_ENT_INFO_NULL == ent_info)
      {
         return NCSCC_RC_NO_INSTANCE;
      }else
      {
      }    
      avm_add_ent_str_info(avm_cb, ent_info, &ep);
   }
   if(TRUE == test_flag)
   {
      return NCSCC_RC_SUCCESS;
   }   
   switch(arg->req.info.set_req.i_param_val.i_param_id)
   {
      case ncsAvmEntHelperPayload_ID:
      {
         AVM_ENT_PATH_STR_T helper_ep;
         /* If same Value, return Success */
         if (!AVM_DHCONF_MEMCMP_LEN(ent_info->dhcp_serv_conf.ipmc_helper_node.name,
            arg->req.info.set_req.i_param_val.info.i_oct,
            ent_info->dhcp_serv_conf.ipmc_helper_node.length,
            arg->req.info.set_req.i_param_val.i_length))
            return NCSCC_RC_SUCCESS;

         m_NCS_MEMSET(helper_ep.name, '\0', AVM_MAX_INDEX_LEN);
 
         /* Validate the helper payload entity path */
         if (NCSCC_RC_SUCCESS != avm_convert_nodeid_to_entpath(arg->req.info.set_req.i_param_val,&helper_ep))
         {
            m_AVM_LOG_DEBUG("AVM-SSU: not a valid node_id", NCSFL_SEV_ERROR);
            goto failure;
         }

         /*saumya-fix for IR00086315*/
         if ((ent_info->ep_str.length == helper_ep.length)
             &&
             (!m_NCS_MEMCMP(ent_info->ep_str.name,
                            helper_ep.name,
                            helper_ep.length)))         
         {
            sprintf(logbuf,"AVM-SSU: Payload blade %s : Helper blade same as target payload blade. IPMC upgrade failed",ent_info->ep_str.name);
            m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);
            return NCSCC_RC_INV_VAL;
         }


         if (!(arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME))
         {
            /* Check for the presense of helper payload blade */
            if (FALSE == avm_is_the_helper_payload_present(avm_cb,helper_ep))
            {
               /* log the error */
               sprintf(logbuf,"AVM-SSU: Payload blade %s : Helper blade not present. IPMC upgrade failed",ent_info->ep_str.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);
               return NCSCC_RC_INV_VAL;
            }
         }
         /* store the helper entity path, for future reference */
         ent_info->dhcp_serv_conf.ipmc_helper_ent_path.length = helper_ep.length;
         m_NCS_MEMCPY(ent_info->dhcp_serv_conf.ipmc_helper_ent_path.name, helper_ep.name,helper_ep.length);

         m_NCS_MEMSET(ent_info->dhcp_serv_conf.ipmc_helper_node.name, '\0', AVM_NAME_STR_LENGTH); 
         /* Copy the ipmc helper node */
         m_AVM_SET_NAME(ent_info->dhcp_serv_conf.ipmc_helper_node,
            arg->req.info.set_req.i_param_val);

         sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: ncsAvmEntHelperPayload_ID SET to %s",
                              ent_info->ep_str.name,ent_info->dhcp_serv_conf.ipmc_helper_node.name);
         m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);

         /* compute the IPMB address for the target blade */
         avm_compute_ipmb_address(ent_info); 
         ckpt_upgd_state = TRUE;
      }
      break;
      case ncsAvmEntUpgradeType_ID:
      {
         /* if same value, return success */
         if (ent_info->dhcp_serv_conf.upgrade_type == arg->req.info.set_req.i_param_val.info.i_int)
         {
            return NCSCC_RC_SUCCESS;
         } 
         else
         {
            ent_info->dhcp_serv_conf.upgrade_type = arg->req.info.set_req.i_param_val.info.i_int;
            ckpt_upgd_state = TRUE;
         }
      }
      break;
      case ncsAvmEntAdminOper_ID:
      {
         /* Just set the object in case of play-back from PSSV */
         if ( arg->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME )
         {
            ent_info->dhcp_serv_conf.adm_oper =
                arg->req.info.set_req.i_param_val.info.i_int;

            break;
         }

         /* Set admin operation object and take corresponding actions */
         if (AVM_DHCP_COMMIT == arg->req.info.set_req.i_param_val.info.i_int)
         {
            if (SSU_COMMIT_PENDING == ent_info->dhcp_serv_conf.label1.status)
            {
               ent_info->dhcp_serv_conf.label1.status = SSU_COMMITTED;
               /* vivek_push */
               /* PUSH it into PSSV */
               m_AVM_SSU_PSSV_PUSH_INT(avm_cb, ent_info->dhcp_serv_conf.label1.status, ncsAvmEntDHCPConfLabel1Status_ID, ent_info);

               ent_info->dhcp_serv_conf.default_chg = FALSE;
               ckpt_dhstate = TRUE;
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: %s's state SSU_COMMITTED",ent_info->ep_str.name,ent_info->dhcp_serv_conf.label1.name.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 

               /* Reset the IPMC upgrade flags */
               ent_info->dhcp_serv_conf.pld_bld_ipmc_status = 0;
               ent_info->dhcp_serv_conf.pld_rtm_ipmc_status = 0;  
            }
            else if (SSU_COMMIT_PENDING == ent_info->dhcp_serv_conf.label2.status)
            {
               ent_info->dhcp_serv_conf.label2.status = SSU_COMMITTED;
               /* vivek_push */
               /* PUSH it into PSSV */
               m_AVM_SSU_PSSV_PUSH_INT(avm_cb, ent_info->dhcp_serv_conf.label2.status, ncsAvmEntDHCPConfLabel2Status_ID, ent_info);

               ent_info->dhcp_serv_conf.default_chg = FALSE;
               ckpt_dhstate = TRUE;
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: %s's state SSU_COMMITTED",ent_info->ep_str.name,ent_info->dhcp_serv_conf.label2.name.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE); 
 
               /* Reset the IPMC upgrade flags */
               ent_info->dhcp_serv_conf.pld_bld_ipmc_status = 0;
               ent_info->dhcp_serv_conf.pld_rtm_ipmc_status = 0;  
            }
            else
            {
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: Can't COMMIT the LABEL, it is not in COMMIT_PENDING State",ent_info->ep_str.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);
               goto failure;
            }

            /* Set default label and preferred label */
            ent_info->dhcp_serv_conf.default_label = ent_info->dhcp_serv_conf.curr_act_label;

            /* Set the preferred label also to other label */
            ent_info->dhcp_serv_conf.pref_label.length = ent_info->dhcp_serv_conf.default_label->name.length;
            m_NCS_MEMCPY(ent_info->dhcp_serv_conf.pref_label.name, ent_info->dhcp_serv_conf.default_label->name.name,
                ent_info->dhcp_serv_conf.pref_label.length);

            /* Push preferred label into PSSv */
            m_AVM_SSU_PSSV_PUSH_STR(avm_cb, ent_info->dhcp_serv_conf.pref_label.name, ncsAvmEntDHCPConfPrefLabel_ID, ent_info, ent_info->dhcp_serv_conf.pref_label.length );

            ckpt_dhconf = TRUE;
            ckpt_dhstate = TRUE;
            ckpt_upgd_state = TRUE;

            ent_info->dhcp_serv_conf.adm_oper = 
               arg->req.info.set_req.i_param_val.info.i_int;
         }
         else if(AVM_DHCP_UPGRADE == arg->req.info.set_req.i_param_val.info.i_int)
         {
            if ((ent_info->dhcp_serv_conf.ipmc_upgd_state != 0) || (ent_info->dhcp_serv_conf.upgd_prgs == TRUE))
            {
                /* Upgrade is already in progress */
                sysf_sprintf(logbuf, "AVM-SSU: Payload %s: Upgrade is already in progress. Upgrade not allowed", ent_info->ep_str.name);
                m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);
                goto failure;
            }
            /*saumya-fix for IR00086294*/
            if (ent_info->dhcp_serv_conf.curr_act_label == NULL)
            {
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: No current active label. Upgrade not allowed",ent_info->ep_str.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);
               goto failure;
            }

            /* Check for the uType. The uType should be either INTEG or IPMC */
            if( (IPMC == ent_info->dhcp_serv_conf.upgrade_type) )
            {
               ent_info->dhcp_serv_conf.ipmc_upgd_state = IPMC_UPGD_TRIGGERED;
               m_AVM_SEND_CKPT_UPDT_SYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_UPGD_STATE_CHG); 
               ent_info->dhcp_serv_conf.adm_oper = arg->req.info.set_req.i_param_val.info.i_int;
               /* Trigger the IPMC Upgrade */
               /*saumya- fix for IR00086299*/ 
               rc =  avm_upgrade_ipmc_trigger(avm_cb,ent_info);
               if (rc == NCSCC_RC_FAILURE)
               {
                  sysf_sprintf(logbuf, "AVM-SSU: Payload %s: IPMC upgrade trigger failed", ent_info->ep_str.name);
                  m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);

                  ent_info->dhcp_serv_conf.ipmc_upgd_state = 0;
                  m_AVM_SEND_CKPT_UPDT_SYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_UPGD_STATE_CHG);
                  goto failure; 
               }  
            }
            else if(INTEG == ent_info->dhcp_serv_conf.upgrade_type)  
            {
               /* Check for the preffered label. If it is the current active label, no need to upgrade. *
                * If the preffered label is passive label, trigger the upgrade.                         */  

               /*saumya-fix for IR00086310*/

               if ((ent_info->dhcp_serv_conf.pref_label.length ==
                    ent_info->dhcp_serv_conf.curr_act_label->name.length)
                   &&
                   (!m_NCS_MEMCMP(ent_info->dhcp_serv_conf.pref_label.name,
                                  ent_info->dhcp_serv_conf.curr_act_label->name.name,
                                  ent_info->dhcp_serv_conf.pref_label.length)))
               {
                  sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: Preferred label is the current active label. No Upgrade",ent_info->ep_str.name);
                  m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_NOTICE);
               }
               else if ((ent_info->dhcp_serv_conf.pref_label.length == ent_info->dhcp_serv_conf.curr_act_label->other_label->name.length)
                        &&
                        (!m_NCS_MEMCMP(ent_info->dhcp_serv_conf.pref_label.name,
                                       ent_info->dhcp_serv_conf.curr_act_label->other_label->name.name,
                                       ent_info->dhcp_serv_conf.pref_label.length)))
               {
                  ent_info->dhcp_serv_conf.ipmc_upgd_state = IPMC_UPGD_TRIGGERED;
                  m_AVM_SEND_CKPT_UPDT_SYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_UPGD_STATE_CHG); 
                  ent_info->dhcp_serv_conf.adm_oper = 
                     arg->req.info.set_req.i_param_val.info.i_int;
                  /* Trigger the INTEG (IPMC + SW-BIOS i.e mother of all upgrades...) Upgrade */
                  rc = avm_upgrade_ipmc_trigger(avm_cb,ent_info);
 
                  if (rc == NCSCC_RC_FAILURE)
                  {
                     sysf_sprintf(logbuf, "AVM-SSU: Payload %s: INTEG upgrade trigger failed", ent_info->ep_str.name);
                     m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);

                     /*saumya- fix for IR00086299*/ 
                     ent_info->dhcp_serv_conf.ipmc_upgd_state = 0;

                     /* This is taken as upgrade failure */
                     /* We would rollback the labels     */
                     AVM_ENT_DHCP_CONF *dhcp_conf = &ent_info->dhcp_serv_conf;
                     /* change the state to upgrade failure */
                     ent_info->dhcp_serv_conf.curr_act_label->other_label->status = SSU_UPGD_FAILED;

                     /* Push the Label1 state into PSSV */
                     m_AVM_SSU_PSSV_PUSH_INT(avm_cb, ent_info->dhcp_serv_conf.label1.status, 
                                             ncsAvmEntDHCPConfLabel1Status_ID, ent_info);
                     /* Push the Label2 state into PSSV */
                     m_AVM_SSU_PSSV_PUSH_INT(avm_cb, ent_info->dhcp_serv_conf.label2.status, 
                                             ncsAvmEntDHCPConfLabel2Status_ID, ent_info);

                     /* rollback the preferred label */
                     if (dhcp_conf->def_label_num == AVM_DEFAULT_LABEL_1)
                         dhcp_conf->def_label_num = AVM_DEFAULT_LABEL_2;
                     else
                         dhcp_conf->def_label_num = AVM_DEFAULT_LABEL_1;
                     dhcp_conf->default_label = dhcp_conf->default_label->other_label;
                     /* Set the preferred label also to other label */
                     dhcp_conf->pref_label.length = dhcp_conf->default_label->name.length;
                     m_NCS_MEMCPY(dhcp_conf->pref_label.name, dhcp_conf->default_label->name.name,
                                  dhcp_conf->pref_label.length);

                     /* Push preferred label into PSSv */
                     m_AVM_SSU_PSSV_PUSH_STR(avm_cb, ent_info->dhcp_serv_conf.pref_label.name, 
                                             ncsAvmEntDHCPConfPrefLabel_ID, ent_info, 
                                             ent_info->dhcp_serv_conf.pref_label.length );

                     dhcp_conf->default_chg = FALSE;    
                     m_AVM_SEND_CKPT_UPDT_ASYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_DHCP_STATE_CHG);

                     ent_info->dhcp_serv_conf.ipmc_upgd_state = 0;
                     m_AVM_SEND_CKPT_UPDT_SYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_UPGD_STATE_CHG);
                  }
               }
               else
               {
                  sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: Not a valid Preferred label.",ent_info->ep_str.name);
                  m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);
                  goto failure;
               }
            }  
            else
            {
               sysf_sprintf(logbuf,"AVM-SSU: Payload blade %s: Invalid Operation",ent_info->ep_str.name);
               m_AVM_LOG_DEBUG(logbuf,NCSFL_SEV_ERROR);  
               goto failure;
            }
         }
         else
         {
            m_AVM_LOG_DEBUG("AVM-SSU: Invalid Operation", NCSFL_SEV_ERROR);
            goto failure;
         }
      }
      break;
      default:
      {
         goto failure;
      }
   }    
   /* async update */
   if (ckpt_dhconf == TRUE)
      m_AVM_SEND_CKPT_UPDT_ASYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_DHCP_CONF_CHG);
   if (ckpt_dhstate == TRUE)
      m_AVM_SEND_CKPT_UPDT_ASYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_DHCP_STATE_CHG);
   if(ckpt_upgd_state == TRUE)
   {
      m_AVM_SEND_CKPT_UPDT_ASYNC_UPDT(avm_cb, ent_info, AVM_CKPT_ENT_UPGD_STATE_CHG); 
   }

   return NCSCC_RC_SUCCESS;

failure:
   m_AVM_LOG_INVALID_VAL_ERROR(arg->req.info.set_req.i_param_val.i_param_id);
   return NCSCC_RC_FAILURE;
}
EXTERN_C uns32
ncsavmentupgradetableentry_extract(
                                   NCSMIB_PARAM_VAL *param,
                                   NCSMIB_VAR_INFO  *var_info, 
                                   NCSCONTEXT data,
                                   NCSCONTEXT buffer
                                 )
{
   AVM_ENT_INFO_T *ent_info = (AVM_ENT_INFO_T*) data;

   m_AVM_LOG_FUNC_ENTRY("ncsavmentdeploytableentry_extract");   
   
   if(AVM_ENT_INFO_NULL == ent_info)
   {
      m_AVM_LOG_DEBUG("\n Row Not Found",NCSFL_SEV_ERROR);
      return NCSCC_RC_NO_INSTANCE;
   }

   switch(param->i_param_id)
   {
      case ncsAvmEntHelperPayload_ID:
      {
         param->i_fmat_id = NCSMIB_FMAT_OCT;
         param->i_length  = ent_info->dhcp_serv_conf.ipmc_helper_node.length;
         m_NCS_MEMCPY((uns8*)buffer, ent_info->dhcp_serv_conf.ipmc_helper_node.name, param->i_length);
         param->info.i_oct = (uns8*)buffer;
      }
      break;
      case ncsAvmEntUpgradeType_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = ent_info->dhcp_serv_conf.upgrade_type;
      }
      break;
      case ncsAvmEntAdminOper_ID:
      {
         param->i_fmat_id  = NCSMIB_FMAT_INT;
         param->i_length   = 1;
         param->info.i_int = ent_info->dhcp_serv_conf.adm_oper;
      }
      break;
      default:
      {
         m_AVM_LOG_DEBUG("Invalid Param Id Passed", NCSFL_SEV_CRITICAL);
         return NCSCC_RC_FAILURE;
      }
   }
   return NCSCC_RC_SUCCESS;
}
EXTERN_C uns32
ncsavmentupgradetableentry_get(
                               NCSCONTEXT  cb,
                               NCSMIB_ARG  *arg,
                               NCSCONTEXT  *data
                             )
{
   AVM_CB_T            *avm_cb;
   AVM_ENT_INFO_T      *ent_info;
   AVM_ENT_PATH_STR_T   ep_str;      

   uns8      i;

   m_AVM_LOG_FUNC_ENTRY("ncsavmentupgradetableentry_get");
   
   avm_cb   = (AVM_CB_T*)cb;

   m_NCS_MEMSET(ep_str.name, '\0', AVM_MAX_INDEX_LEN);

   ep_str.length   = arg->i_idx.i_inst_ids[0];
   for(i = 0; i < ep_str.length; i++)
   {
      ep_str.name[i] = (uns8)(arg->i_idx.i_inst_ids[i + 1]);
   }

   ent_info = avm_find_ent_str_info(avm_cb, &ep_str,TRUE);

   if(AVM_ENT_INFO_NULL == ent_info)
   {
      return NCSCC_RC_NO_INSTANCE;
   }   

   *data = (NCSCONTEXT)ent_info;
   
   return NCSCC_RC_SUCCESS;
}

EXTERN_C uns32
ncsavmentupgradetableentry_next(
                                 NCSCONTEXT   cb,
                                 NCSMIB_ARG  *arg,
                                 NCSCONTEXT  *data,
                                 uns32       *next_inst_id,
                                 uns32       *next_inst_id_len
                              )
{
   AVM_CB_T           *avm_cb = (AVM_CB_T*)cb;
   AVM_ENT_INFO_T     *ent_info;
   AVM_ENT_PATH_STR_T  ep_str;      
   uns32               i;

   m_AVM_LOG_FUNC_ENTRY("ncsavmentupgradetableentry_next");

   m_NCS_MEMSET(ep_str.name, '\0', AVM_MAX_INDEX_LEN);

   if(arg->i_idx.i_inst_len  != 0)
   {
      ep_str.length   = arg->i_idx.i_inst_ids[0];
      for(i = 0; i < ep_str.length; i++)
      {
         ep_str.name[i] = (uns8)(arg->i_idx.i_inst_ids[i + 1]);
      }
   }else
   {
      ep_str.length = 0;
      ent_info = avm_find_next_ent_str_info(avm_cb, &ep_str);
      if(AVM_ENT_INFO_NULL == ent_info)
      {
         return NCSCC_RC_NO_INSTANCE;   
      } 
      
      ep_str.length = m_NCS_OS_NTOHS(ent_info->ep_str.length);
      m_NCS_MEMCPY(ep_str.name, ent_info->ep_str.name, ep_str.length);
   }
  
   ent_info = avm_find_next_ent_str_info(avm_cb, &ep_str);
   if(AVM_ENT_INFO_NULL == ent_info) 
   {
      return NCSCC_RC_NO_INSTANCE;   
   }
      
   /* Fill next instance index */

   *next_inst_id_len = m_NCS_OS_NTOHS(ent_info->ep_str.length) + 1; 

    next_inst_id[0]  = *next_inst_id_len - 1;
    
    for(i = 0; i < next_inst_id[0]; i++)
    {
       next_inst_id[i + 1] = (uns32)(ent_info->ep_str.name[i]);   
    }      
    
    (*data) = (NCSCONTEXT) ent_info;

    return NCSCC_RC_SUCCESS;   
}
EXTERN_C uns32
ncsavmentupgradetableentry_setrow(
                                 NCSCONTEXT               cb,
                                 NCSMIB_ARG              *args,
                                 NCSMIB_SETROW_PARAM_VAL *params,
                                 struct ncsmib_obj_info  *obj_info,
                                 NCS_BOOL                 testrow_flag
                               )
{
    return NCSCC_RC_SUCCESS;   
}
EXTERN_C uns32
ncsavmentupgradetableentry_verify_instance(NCSMIB_ARG* args)
{
    return NCSCC_RC_SUCCESS; 
}

