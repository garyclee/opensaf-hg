/*      -*- OpenSAF  -*-
 *
 * (C) Copyright 2008 The OpenSAF Foundation 
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
 * under the GNU Lesser General Public License Version 2.1, February 1999.
 * The complete license can be accessed from the following location:
 * http://opensource.org/licenses/lgpl-license.php 
 * See the Copying file included with the OpenSAF distribution for full
 * licensing terms.
 *
 * Author(s): Emerson Network Power
 *   
 */

/*****************************************************************************
..............................................................................
  
  ..............................................................................
 
  DESCRIPTION:This module deals wih registering AvM with MDS and provides the
  callbacks for MDS .
  ..............................................................................

  Function Included in this Module:

  avm_miblib_init    -
  avm_mab_init       - 
  avm_mab_detroy     - 
  avm_mab_reg_tbls   -
  avm_mab_unreg_tbls - 
  avm_mab_reg_rows   -
  avm_mab_unreg_rows -
  avm_rcv_mab_req    -
 
******************************************************************************
*/
/*********************************************************************
 * Inclusion Control
 ********************************************************************/

#include "avm.h"

typedef  uns32 (*AVM_MIBLIB_REG_FUNC)();
static   uns32 avm_mab_reg_rows(AVM_CB_T *cb);
static   uns32 avm_mab_unreg_rows(AVM_CB_T *cb);

/********************************************************************** 
* Array of function pointers to be registered MIBLIB.  These are the 
* routines generated by MIBLIB tool and are in the files
* <tabel_name>_mib.c file.
 **********************************************************************/
static AVM_MIBLIB_REG_FUNC 
   avm_miblib_reg_func[NCSMIB_TBL_AVM_END - NCSMIB_TBL_AVM_BASE +  1] = 
{
   ncsavmscalars_tbl_reg,
   ncsavmentdeploytableentry_tbl_reg,   
   ncsavmentfaultdomaintableentry_tbl_reg,
};
/*
static AVM_MIBLIB_REG_FUNC 
   avm_miblib_reg_func[4] = 
{
   ncsavmscalars_tbl_reg,
   ncsavmentdeploytableentry_tbl_reg,   
   ncsavmentfaultdomaintableentry_tbl_reg,
   ncsavmentupgradetableentry_tbl_reg
};
*/


/***********************************************************************
 * Function: avm_rcv_mab_req
 *
 * Purpose:  This function is the callback function registered by AVM 
 *           for all the AVM tables with MAB. This function maps the MIB
 *           arg structure received into event structure to be interprete
 *           d by AvM FSM.
 *
 * Input:    req:  The MIB request pointer. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 **********************************************************************/

static uns32 
avm_rcv_mab_req(struct ncsmib_arg* req)
{
   AVM_EVT_T   *evt = AVM_EVT_NULL;
   AVM_CB_T    *cb  = AVM_CB_NULL;

   uns32 cb_hdl;

   /* Check if req is NULL */
   if (NULL == req)
   {
      m_AVM_LOG_INVALID_VAL_FATAL(0);
      return NCSCC_RC_FAILURE;
   }

   /* get the CB from the handle manager */
   if ( AVM_CB_NULL == (cb = (AVM_CB_T *)ncshm_take_hdl(NCS_SERVICE_ID_AVM, (uns32)(req->i_mib_key))))
   {
      m_AVM_LOG_CB(AVM_LOG_CB_RETRIEVE, AVM_LOG_CB_FAILURE, NCSFL_SEV_CRITICAL);
      m_MMGR_FREE_AVM_EVT(evt);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      return NCSCC_RC_FAILURE;
   }
   cb_hdl   = (uns32)(req->i_mib_key);

   evt = m_MMGR_ALLOC_AVM_EVT;
   if (AVM_EVT_NULL == evt)
   {
      m_AVM_LOG_MEM(AVM_LOG_EVT_ALLOC, AVM_LOG_MEM_ALLOC_FAILURE, NCSFL_SEV_EMERGENCY);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      ncshm_give_hdl(cb_hdl);
      return NCSCC_RC_FAILURE;
   }

   evt->src = AVM_EVT_MIB;

   /* make a copy of the MIB request */
   evt->evt.mib_req = ncsmib_memcopy(req);

   if (NULL == evt->evt.mib_req)
   {
      m_AVM_LOG_MAS(AVM_LOG_MIB_CPY, AVM_LOG_MAS_FAILURE, NCSFL_SEV_EMERGENCY);     
      m_MMGR_FREE_AVM_EVT(evt);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      ncshm_give_hdl(cb_hdl); /* Return CB hdl */  
      return NCSCC_RC_FAILURE;
   }

   if (m_NCS_IPC_SEND(&cb->mailbox, evt, NCS_IPC_PRIORITY_VERY_HIGH) 
            != NCSCC_RC_SUCCESS)
   {
      m_AVM_LOG_MBX(AVM_LOG_MBX_SEND, AVM_LOG_MBX_FAILURE, NCSFL_SEV_EMERGENCY);
      m_MMGR_FREE_AVM_EVT(evt);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      ncshm_give_hdl(cb_hdl); /*Return CB hdl */
      return NCSCC_RC_FAILURE;
   }

   ncshm_give_hdl(cb_hdl);
   return NCSCC_RC_SUCCESS;
}

/***********************************************************************
 * Function: avm_mab_reg_tbls
 *
 * Purpose:  This function is used to register MIB tables with MAB.
 *
 * Input:    AVM Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 * 
 **********************************************************************/

static uns32 avm_mab_reg_tbls(AVM_CB_T *cb)
{
   NCSOAC_SS_ARG            avm_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32 rc = NCSCC_RC_SUCCESS ;

   /* Register for all tables */
   m_NCS_MEMSET(&avm_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avm_oac_arg.i_oac_hdl = cb->mab_hdl;
   avm_oac_arg.i_op      = NCSOAC_SS_OP_TBL_OWNED;
   avm_oac_arg.info.tbl_owned.i_mib_key = (uns64)(cb->cb_hdl);
   avm_oac_arg.info.tbl_owned.i_mib_req = avm_rcv_mab_req;
   avm_oac_arg.info.tbl_owned.i_ss_id   = NCS_SERVICE_ID_AVM;

   avm_oac_arg.info.tbl_owned.i_pcn         = "AVM";

   for (tbl_id  = NCSMIB_TBL_AVM_BASE;
        tbl_id <= NCSMIB_TBL_AVM_END;
        tbl_id ++)
   {
      avm_oac_arg.info.tbl_owned.is_persistent = TRUE;

      if((NCSMIB_TBL_AVM_ENT_FAULT_DOMAIN == tbl_id) || (NCSMIB_TBL_AVM_TRAPS == tbl_id) )
      {
         continue;   
      }
      else if(NCSMIB_TBL_AVM_SCALAR == tbl_id)
      {
         avm_oac_arg.info.tbl_owned.is_persistent = FALSE;
      }

      avm_oac_arg.i_tbl_id  = tbl_id; 
      if(NCSCC_RC_SUCCESS  != ncsoac_ss(&avm_oac_arg))
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_TBL, AVM_LOG_MAS_FAILURE, NCSFL_SEV_EMERGENCY);
         rc = NCSCC_RC_FAILURE;
         continue;
      }else
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_TBL, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
      }
     
   } 

   /* vivek_avm */
   /* Register the new Avm Table */
   avm_oac_arg.info.tbl_owned.is_persistent = TRUE;
   tbl_id = NCSMIB_TBL_AVM_UPGRADE;
   avm_oac_arg.i_tbl_id  = tbl_id;
   if(NCSCC_RC_SUCCESS  != ncsoac_ss(&avm_oac_arg))
   {
      m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_TBL, AVM_LOG_MAS_FAILURE, NCSFL_SEV_EMERGENCY);
      rc = NCSCC_RC_FAILURE;
   }else
   {
      m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_TBL, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
   }
   return rc;
}


/***********************************************************************
 * Function: avm_mab_unreg_tbls
 *
 * Purpose:  This function is to unregister AvM MIB tables with MAB. 
 *
 * Input:    AVM Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * 
 **********************************************************************/
static uns32 avm_mab_unreg_tbls(AVM_CB_T *cb)
{
   NCSOAC_SS_ARG            avm_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32           rc = NCSCC_RC_SUCCESS ;

   /* Register MIB tables */
   m_NCS_MEMSET(&avm_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avm_oac_arg.i_oac_hdl = cb->mab_hdl;
   avm_oac_arg.i_op      = NCSOAC_SS_OP_TBL_GONE;

   for (tbl_id  = NCSMIB_TBL_AVM_BASE;
        tbl_id <= NCSMIB_TBL_AVM_END;
        tbl_id ++)
   {
      
      if((NCSMIB_TBL_AVM_ENT_FAULT_DOMAIN == tbl_id) || (NCSMIB_TBL_AVM_TRAPS == tbl_id) )
      {
         continue;   
      }
      avm_oac_arg.i_tbl_id  = tbl_id;
      if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_TBL, AVM_LOG_MAS_FAILURE, NCSFL_SEV_CRITICAL);
         rc = NCSCC_RC_FAILURE;
         continue;
      }
      else
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_TBL, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
      }
     
   }  

   /* vivek_avm */
   /* Un-register the new Avm Table */
   tbl_id = NCSMIB_TBL_AVM_UPGRADE;
   avm_oac_arg.i_tbl_id  = tbl_id;
   if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
   {
     m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_TBL, AVM_LOG_MAS_FAILURE, NCSFL_SEV_CRITICAL);
     rc = NCSCC_RC_FAILURE;
   }
   else
   {
     m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_TBL, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
   }
   return rc;
}

extern uns32 
avm_mab_send_warmboot_req(AVM_CB_T *cb)
{
   NCSOAC_SS_ARG            avm_oac_arg;
                                                                                
   m_AVM_LOG_FUNC_ENTRY("avm_mab_send_warmboot_req");
                                                                                
   m_NCS_MEMSET(&avm_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
                                                                                
   avm_oac_arg.i_oac_hdl = cb->mab_hdl;
   avm_oac_arg.i_op      = NCSOAC_SS_OP_WARMBOOT_REQ_TO_PSSV;
   avm_oac_arg.info.warmboot_req.i_pcn = "AVM";
   avm_oac_arg.info.warmboot_req.is_system_client = TRUE;
                                                                                
   if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
   {
      m_AVM_LOG_MAS(AVM_LOG_PSS_REGISTER, AVM_LOG_MAS_FAILURE, NCSFL_SEV_CRITICAL);   
      return NCSCC_RC_FAILURE;
   }
                                                                                
   return NCSCC_RC_SUCCESS;
}

/**********************************************************************
  Name          : avm_mab_init
 
  Description   : This routine initializes MAB OAC.
 
  Arguments     : cb - ptr to the AVM control block
 
  Return Values : NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 
  Notes         : None.
***********************************************************************/
uns32 avm_mab_init (AVM_CB_T *cb)
{

   if (NCSCC_RC_SUCCESS != avm_mab_reg_tbls(cb))
   {
      m_NCS_DBG_PRINTF("\n TABLE REGISTRATION WITH MAB FAILED ");   
      avm_mab_unreg_tbls(cb);
      return NCSCC_RC_FAILURE;
   }

   if (NCSCC_RC_SUCCESS != avm_mab_reg_rows(cb))
   {
         m_NCS_DBG_PRINTF("\n ROWS REGISTRATION WITH MAB FAILED ");   
         avm_mab_unreg_rows(cb);
         avm_mab_unreg_tbls(cb);
         return NCSCC_RC_FAILURE;
   }

   return NCSCC_RC_SUCCESS;
}


/***********************************************************************
 * Function: avm_mab_reg_rows
 *
 * Purpose:  This function registers  MIB table rows with MAB. 
 *
 * Input:    AVM control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * 
 **********************************************************************/

static uns32 avm_mab_reg_rows(AVM_CB_T *cb)
{
   NCSOAC_SS_ARG            avm_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32           rc = NCSCC_RC_SUCCESS ;

   /* Register for all tables rows*/
   m_NCS_MEMSET(&avm_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avm_oac_arg.i_oac_hdl = cb->mab_hdl;
   avm_oac_arg.i_op      = NCSOAC_SS_OP_ROW_OWNED;
   avm_oac_arg.info.row_owned.i_fltr.type = NCSMAB_FLTR_ANY;
   avm_oac_arg.info.row_owned.i_fltr.is_move_row_fltr = FALSE;
   avm_oac_arg.info.row_owned.i_ss_cb     = (NCSOAC_SS_CB)NULL;
   avm_oac_arg.info.row_owned.i_ss_hdl    = cb->cb_hdl;

   for (tbl_id  = NCSMIB_TBL_AVM_BASE;
        tbl_id <= NCSMIB_TBL_AVM_END;
        tbl_id ++)
   {
      if((NCSMIB_TBL_AVM_ENT_FAULT_DOMAIN == tbl_id) || (NCSMIB_TBL_AVM_TRAPS == tbl_id) )
      {
         continue;   
      }

      avm_oac_arg.i_tbl_id  = tbl_id;
      if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_ROW, AVM_LOG_MAS_FAILURE, NCSFL_SEV_EMERGENCY);
         rc = NCSCC_RC_FAILURE;
         continue;
      }

      cb->mab_row_hdls[tbl_id - NCSMIB_TBL_AVM_BASE] =
                     avm_oac_arg.info.row_owned.o_row_hdl;
      m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_ROW, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
     
   } 
   /* vivek_avm */
   /* Register the new Avm Table row */
   tbl_id = NCSMIB_TBL_AVM_UPGRADE;
   avm_oac_arg.i_tbl_id  = tbl_id;
   if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
   {
      m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_ROW, AVM_LOG_MAS_FAILURE, NCSFL_SEV_EMERGENCY);
      rc = NCSCC_RC_FAILURE;
   }
   else
   {
      cb->mab_row_hdls[4] = avm_oac_arg.info.row_owned.o_row_hdl;
      m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_REGISTER_ROW, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);   
   }

   return rc;
}


/***********************************************************************
 * Function: avm_mab_unreg_rows
 *
 * Purpose:  This function  is to unregister MIB tables with MAB. 
 *
 * Input:    AVM Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 **********************************************************************/

static uns32 avm_mab_unreg_rows(AVM_CB_T *cb)
{
   NCSOAC_SS_ARG            avm_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32                    rc = NCSCC_RC_SUCCESS ;

   m_NCS_MEMSET(&avm_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avm_oac_arg.i_oac_hdl = cb->mab_hdl;
   avm_oac_arg.i_op      = NCSOAC_SS_OP_ROW_GONE;

   for (tbl_id  = NCSMIB_TBL_AVM_BASE;
        tbl_id <= NCSMIB_TBL_AVM_END;
        tbl_id ++)
   {
      if((NCSMIB_TBL_AVM_ENT_FAULT_DOMAIN == tbl_id) || (NCSMIB_TBL_AVM_TRAPS == tbl_id) )
      {
         continue;   
      }

      avm_oac_arg.i_tbl_id = tbl_id;
      avm_oac_arg.info.row_gone.i_row_hdl = 
         cb->mab_row_hdls[tbl_id - NCSMIB_TBL_AVM_BASE];

      if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_ROW, AVM_LOG_MAS_FAILURE, NCSFL_SEV_CRITICAL);
         rc = NCSCC_RC_FAILURE;
         continue;
      }
      m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_ROW, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);   
     
   } 

   /* vivek_avm */
   /* Un-register the new Avm Table row */
   tbl_id = NCSMIB_TBL_AVM_UPGRADE;
   avm_oac_arg.i_tbl_id = tbl_id;
   avm_oac_arg.info.row_gone.i_row_hdl = cb->mab_row_hdls[4];
   if(ncsoac_ss(&avm_oac_arg) != NCSCC_RC_SUCCESS)
   {
     m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_ROW, AVM_LOG_MAS_FAILURE, NCSFL_SEV_CRITICAL);
     rc = NCSCC_RC_FAILURE;
   }
   else
   {
     m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_OAC_UNREGISTER_ROW, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
   }

   return rc;
}

/**********************************************************************
  Name          : avm_mab_destroy
 
  Description   : This routine destroys MAB OAC.
 
  Arguments     : cb - ptr to the AVM control block
 
  Return Values : NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 
  Notes         : None.
***********************************************************************/
uns32 avm_mab_destroy(AVM_CB_T *cb)
{
   uns32 rc;

   rc = avm_mab_unreg_rows(cb);
   if(NCSCC_RC_SUCCESS != rc)
   {
      rc = NCSCC_RC_FAILURE;
   }
   rc = avm_mab_unreg_tbls(cb);
   if(NCSCC_RC_SUCCESS != rc)
   {
      rc = NCSCC_RC_FAILURE;
   }

   return rc;
}

/***********************************************************************
  Name          : avm_miblib_init
 
  Description   : This routine registers SMI-DUMP tool generated routine
                  with MIBLIB.
 
  Arguments     : cb - ptr to the AVM control block
 
  Return Values : NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 
***********************************************************************/
uns32 avm_miblib_init(AVM_CB_T *cb)
{
   uns32               rc = NCSCC_RC_SUCCESS; 
   NCSMIB_TBL_ID       tbl_id;  
   AVM_MIBLIB_REG_FUNC reg_func = NULL;

   for(tbl_id = NCSMIB_TBL_AVM_BASE; 
       tbl_id <= NCSMIB_TBL_AVM_END;
       tbl_id ++)
   {     
      /* Register the objects and table data with MIB lib */
      reg_func  = avm_miblib_reg_func[tbl_id - NCSMIB_TBL_AVM_BASE];
      if(NULL  == reg_func)
         continue;

      if(NCSCC_RC_SUCCESS != reg_func())
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_MIBLIB_REGISTER, AVM_LOG_MAS_SKIP, NCSFL_SEV_CRITICAL);
         rc = NCSCC_RC_FAILURE;
         continue;
      }else
      {
         m_AVM_LOG_MAS_VAL(tbl_id, AVM_LOG_MIBLIB_REGISTER, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
      }
      
   }
   
   /* Register the objects and table data with MIB lib for UPGRADE TABLE */
   reg_func  = ncsavmentupgradetableentry_tbl_reg;

   if(NCSCC_RC_SUCCESS != reg_func())
   {
       m_AVM_LOG_MAS_VAL(NCSMIB_TBL_AVM_UPGRADE, AVM_LOG_MIBLIB_REGISTER, AVM_LOG_MAS_SKIP, NCSFL_SEV_CRITICAL);
       rc = NCSCC_RC_FAILURE;
   }else
   {
       m_AVM_LOG_MAS_VAL(NCSMIB_TBL_AVM_UPGRADE, AVM_LOG_MIBLIB_REGISTER, AVM_LOG_MAS_SUCCESS, NCSFL_SEV_INFO);
   }

   return rc; 
}


/******************************************************************************
*  Function :  avm_send_dynamic_data
*
*  Purpose  :  Routine to send the dynamic data to PSS.
*
*  Input    :  struct ncsmib_arg*
*              AVM_CB_T *avm_cb
*
*  Returns  :  NCSCC_RC_SUCCESSS/NCSCC_RC_FAILURE
*
*  Notes    :
******************************************************************************/
uns32
avm_send_dynamic_data(AVM_CB_T *cb, AVM_ENT_INFO_T *ent_info, NCSMIB_PARAM_ID param_id, NCSMIB_FMAT_ID fmt_id, AVM_PSSV_PUSH *avm_pss)
{
   NCSMIB_PARAM_VAL   param_val;
   NCSOAC_SS_ARG      mab_arg;
   NCSMIB_ARG         local_mibarg;
   uns32              inst_ids[250]={0},i;


   param_val.i_param_id = param_id;
   param_val.i_fmat_id =  fmt_id;
 
   m_NCS_MEMSET(&mab_arg,'\0',sizeof(mab_arg));
   ncsmib_init(&local_mibarg);
   mab_arg.i_op = NCSOAC_SS_OP_PUSH_MIBARG_DATA_TO_PSSV;
   mab_arg.i_oac_hdl = cb->mab_hdl;
   mab_arg.i_tbl_id = NCSMIB_TBL_AVM_ENT_DEPLOYMENT;

   for (i=1;i<=ent_info->ep_str.length;i++)
     inst_ids[i] = (uns32) ent_info->ep_str.name[i-1];

   inst_ids[0] = ent_info->ep_str.length;
   local_mibarg.i_op = NCSMIB_OP_RSP_SET;
   local_mibarg.i_tbl_id  = NCSMIB_TBL_AVM_ENT_DEPLOYMENT;
   local_mibarg.i_usr_key = cb->cb_hdl;
   local_mibarg.i_mib_key = cb->mab_hdl;;
   local_mibarg.i_idx.i_inst_ids = inst_ids;
   local_mibarg.i_idx.i_inst_len = inst_ids[0]+1;

   if(fmt_id == NCSMIB_FMAT_INT)
   { 
      /*param_val.i_length  = 4; - TBD */
      param_val.info.i_int = avm_pss->int_val;
   }
   else
   {
      param_val.i_length = avm_pss->oct_str.length;
      param_val.info.i_oct = avm_pss->oct_str.name;
   }
 
   local_mibarg.rsp.info.set_rsp.i_param_val = param_val;

   mab_arg.info.push_mibarg_data.arg = &local_mibarg;
   if (NCSCC_RC_SUCCESS != ncsoac_ss(&mab_arg))
   {
    return NCSCC_RC_FAILURE;
   }

   return NCSCC_RC_SUCCESS;
}

