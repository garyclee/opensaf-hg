/*      -*- OpenSAF  -*-
 *
 * (C) Copyright 2008 The OpenSAF Foundation
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
 * under the GNU Lesser General Public License Version 2.1, February 1999.
 * The complete license can be accessed from the following location:
 * http://opensource.org/licenses/lgpl-license.php
 * See the Copying file included with the OpenSAF distribution for full
 * licensing terms.
 *
 * Author(s): Emerson Network Power
 *
 */

/*****************************************************************************
..............................................................................



..............................................................................

  DESCRIPTION: This module does the initialisation of MAB and provides
  callback functions at Availability Directors. It contains the receive
  callback that is called by MAB for the MIB tables related to AvD.
  The receive function will copy the request to the AvD message structure 
  and sends the message to the main loop for processing. 


..............................................................................

  FUNCTIONS INCLUDED in this module:

  avd_rcv_mab_req - AVD MAB request handler.
  avd_mab_reg_tbls - registers all AVD tables with MAB.
  avd_mab_unreg_tbls - unregisters all AVD tables with MAB.
  avd_mab_init - binds the AVD to MAB.
  avd_mab_reg_rows - registers all AVD tables rows with MAB.
  avd_mab_unreg_rows - unregisters all AVD tables rows with MAB.
  avd_miblib_init - initializes MIBLIB module


  
******************************************************************************
*/

/*
 * Module Inclusion Control...
 */


#include "avd.h"


typedef  uns32 (* AVD_MIBLIB_REG_FUNC)();
/* Array of function pointers for AVD MIBLIB registration routines
 * for the AVD managed MIb tables. 
 * These are the routines generated by MIBLIB tool and are in the files
 * <tabel_name>_mib.c file.
 */

static AVD_MIBLIB_REG_FUNC 
   avd_mib_reg_array[NCSMIB_TBL_AVSV_AVD_END - NCSMIB_TBL_AVSV_BASE + 1] = 
{
   avsvscalars_tbl_reg,                         /* NCSMIB_TBL_AVSV_NCS_SCALAR */
   safclmscalarobject_tbl_reg,                  /* NCSMIB_TBL_AVSV_CLM_SCALAR */
   saamfscalars_tbl_reg,                        /* NCSMIB_TBL_AVSV_AMF_SCALAR */
   saclmnodetableentry_tbl_reg,                 /* NCSMIB_TBL_AVSV_CLM_NODE */
   ncsndtableentry_tbl_reg,                     /* NCSMIB_TBL_AVSV_NCS_NODE */
   saamfnodetableentry_tbl_reg,                 /* NCSMIB_TBL_AVSV_AMF_NODE */
   ncssgtableentry_tbl_reg,                     /* NCSMIB_TBL_AVSV_NCS_SG */
   saamfsgtableentry_tbl_reg,                   /* NCSMIB_TBL_AVSV_AMF_SG */
   ncssutableentry_tbl_reg,                     /* NCSMIB_TBL_AVSV_NCS_SU */
   saamfsutableentry_tbl_reg,                   /* NCSMIB_TBL_AVSV_AMF_SU */
   ncssitableentry_tbl_reg,                     /* NCSMIB_TBL_AVSV_NCS_SI */
   saamfsitableentry_tbl_reg,                   /* NCSMIB_TBL_AVSV_AMF_SI */
   saamfsuspersirankentry_tbl_reg,              /* NCSMIB_TBL_AVSV_AMF_SUS_PER_SI_RANK */
   saamfsgsirankentry_tbl_reg,                  /* NCSMIB_TBL_AVSV_AMF_SG_SI_RANK */
   saamfsgsurankentry_tbl_reg,                  /* NCSMIB_TBL_AVSV_AMF_SG_SU_RANK */
   saamfsisideptableentry_tbl_reg,              /* NCSMIB_TBL_AVSV_AMF_SI_SI_DEP */
   saamfcomptableentry_tbl_reg,                 /* NCSMIB_TBL_AVSV_AMF_COMP */
   saamfcompcstypesupportedtableentry_tbl_reg,  /* NCSMIB_TBL_AVSV_AMF_COMP_CS_TYPE */
   saamfcsitableentry_tbl_reg,                  /* NCSMIB_TBL_AVSV_AMF_CSI */
   saamfcsinamevaluetableentry_tbl_reg,         /* NCSMIB_TBL_AVSV_AMF_CSI_NAME_VALUE */
   saamfcstypeparamentry_tbl_reg,               /* NCSMIB_TBL_AVSV_AMF_CSI_TYPE_PARAM */
   saamfsusitableentry_tbl_reg,                 /* NCSMIB_TBL_AVSV_AMF_SU_SI */
   saamfhealthchecktableentry_tbl_reg           /* NCSMIB_TBL_AVSV_AMF_HLT_CHK */
};                                    






/*****************************************************************************
 * Function: avd_rcv_mab_req
 *
 * Purpose:  This function is the callback function registered by AVD 
 *           for all the AVD tables with MAB. This function packages the
 *           received MIB arg structure into the event structure and
 *           posts a message to the mailbox for processing by the main thread
 *
 * Input:    req:  The MIB request pointer. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * NOTES:None.
 *
 * 
 **************************************************************************/

static uns32 avd_rcv_mab_req(struct ncsmib_arg* req)
{
   AVD_EVT *evt=AVD_EVT_NULL;
   AVD_CL_CB   *cb=AVD_CL_CB_NULL;
   uns32 cb_hdl;

   m_AVD_LOG_FUNC_ENTRY("avd_rcv_mab_req");
   
   /* check that the request ptr is not NULL */
   if (req == NULL)
   {
      m_AVD_LOG_INVALID_VAL_ERROR(0);
      return NCSCC_RC_FAILURE;
   }

   m_AVD_LOG_RCVD_VAL((long)req);
   
   evt = m_MMGR_ALLOC_AVD_EVT;
   if (evt == AVD_EVT_NULL)
   {
      /* log error that the AVD is degraded */
      m_AVD_LOG_MEM_FAIL_LOC(AVD_EVT_ALLOC_FAILED);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      return NCSCC_RC_FAILURE;
   }

   m_AVD_LOG_RCVD_VAL((long)evt);

   /* get the CB from the handle manager */
   if ((cb = (AVD_CL_CB *)ncshm_take_hdl(NCS_SERVICE_ID_AVD,(uns32)(req->i_mib_key))) ==
        AVD_CL_CB_NULL)
   {
      /* log error that the Cb handle provided is invalid.*/
      m_AVD_LOG_INVALID_VAL_ERROR((uns32)req->i_mib_key);
      m_MMGR_FREE_AVD_EVT(evt);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);      
      return NCSCC_RC_FAILURE;
   }

   evt->cb_hdl = cb_hdl = (uns32)(req->i_mib_key);
   evt->rcv_evt = AVD_EVT_MIB_REQ;

   /* make a copy of the MIB request */
   evt->info.mib_req = ncsmib_memcopy(req);

   if (evt->info.mib_req == NULL)
   {
      /* log error that the AVD is degraded */

      /* return AvD CB handle*/
      ncshm_give_hdl(cb_hdl);
      m_MMGR_FREE_AVD_EVT(evt);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      return NCSCC_RC_FAILURE;
   }

   m_AVD_LOG_RCVD_VAL((long)evt->info.mib_req);
   m_AVD_LOG_EVT_INFO(AVD_SND_MAB_EVENT,AVD_EVT_MIB_REQ);

   if (m_NCS_IPC_SEND(&cb->avd_mbx,evt,NCS_IPC_PRIORITY_LOW) 
            != NCSCC_RC_SUCCESS)
   {
      m_AVD_LOG_MBX_ERROR(AVSV_LOG_MBX_SEND);
       /* return AvD CB handle*/
      ncshm_give_hdl(cb_hdl);
      /* log error */
      m_MMGR_FREE_AVD_EVT(evt);
      req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      req->i_op = m_NCSMIB_REQ_TO_RSP(req->i_op);
      req->i_rsp_fnc(req);
      return NCSCC_RC_FAILURE;
   }

   m_AVD_LOG_MBX_SUCC(AVSV_LOG_MBX_SEND);

   /* return AvD CB handle*/
   ncshm_give_hdl(cb_hdl);

   return NCSCC_RC_SUCCESS;
}

uns32 avd_mab_snd_warmboot_req(AVD_CL_CB *cb)
{
   NCSOAC_SS_ARG            avd_oac_arg;

   m_AVD_LOG_FUNC_ENTRY("avd_mab_snd_warmboot_req");
   
   m_NCS_MEMSET(&avd_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avd_oac_arg.i_oac_hdl = cb->mab_hdl;
   avd_oac_arg.i_op      = NCSOAC_SS_OP_WARMBOOT_REQ_TO_PSSV;
   avd_oac_arg.info.warmboot_req.i_pcn = "AVD";
   avd_oac_arg.info.warmboot_req.is_system_client = TRUE;

   if(ncsoac_ss(&avd_oac_arg) != NCSCC_RC_SUCCESS)
   {
      /* Log Error about skipping the table */
      /* Log error */
      return NCSCC_RC_FAILURE;
   }
     
   return NCSCC_RC_SUCCESS;
}

/*****************************************************************************
 * Function: avd_mab_reg_tbls
 *
 * Purpose:  This function registers all AVD tables with MAB. 
 *
 * Input:    AVD Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * NOTES:None.
 *
 * 
 **************************************************************************/

static uns32 avd_mab_reg_tbls(AVD_CL_CB *cb)
{
   NCSOAC_SS_ARG            avd_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32 rc = NCSCC_RC_SUCCESS ;

   m_AVD_LOG_FUNC_ENTRY("avd_mab_reg_tbls");
   
   /* Register for all tables */
   m_NCS_MEMSET(&avd_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avd_oac_arg.i_oac_hdl = cb->mab_hdl;
   avd_oac_arg.i_op      = NCSOAC_SS_OP_TBL_OWNED;
   avd_oac_arg.info.tbl_owned.i_mib_key = (uns64)(cb->cb_handle);
   avd_oac_arg.info.tbl_owned.i_mib_req = avd_rcv_mab_req;
   avd_oac_arg.info.tbl_owned.i_ss_id = NCS_SERVICE_ID_AVD;

   avd_oac_arg.info.tbl_owned.i_pcn = "AVD";

  for (tbl_id  = NCSMIB_TBL_AVSV_BASE;
        tbl_id <= NCSMIB_TBL_AVSV_AVD_END;
        tbl_id ++)
   {
     avd_oac_arg.info.tbl_owned.is_persistent = TRUE;

     if( ((tbl_id >=NCSMIB_TBL_AVSV_AMF_SG_SI_RANK) && 
          (tbl_id <= NCSMIB_TBL_AVSV_AMF_SG_SU_RANK)) ||
          (tbl_id == NCSMIB_TBL_AVSV_AMF_SU_SI) )
       {
          avd_oac_arg.info.tbl_owned.is_persistent = FALSE;
       }

      avd_oac_arg.i_tbl_id  = tbl_id;

      if(ncsoac_ss(&avd_oac_arg) != NCSCC_RC_SUCCESS)
      {
         /* Log Error about skipping the table */
         m_AVD_LOG_INVALID_VAL_ERROR(tbl_id);
         rc = NCSCC_RC_FAILURE;
         continue;
      }
     
   } /* end for tbl_id loop. Registration of all tables */

   return rc;
}


/*****************************************************************************
 * Function: avd_mab_unreg_tbls
 *
 * Purpose:  This function unregisters all AVD tables with MAB. 
 *
 * Input:    AVD Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * NOTES:None.
 *
 * 
 **************************************************************************/

static uns32 avd_mab_unreg_tbls(AVD_CL_CB *cb)
{
   NCSOAC_SS_ARG            avd_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32 rc = NCSCC_RC_SUCCESS ;

   m_AVD_LOG_FUNC_ENTRY("avd_mab_unreg_tbls");
   
   /* Register for all tables */
   m_NCS_MEMSET(&avd_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avd_oac_arg.i_oac_hdl = cb->mab_hdl;
   avd_oac_arg.i_op      = NCSOAC_SS_OP_TBL_GONE;

   for (tbl_id  = NCSMIB_TBL_AVSV_BASE;
        tbl_id <= NCSMIB_TBL_AVSV_AVD_END;
        tbl_id ++)
   {
      
      avd_oac_arg.i_tbl_id  = tbl_id;

      if(ncsoac_ss(&avd_oac_arg) != NCSCC_RC_SUCCESS)
      {
         /* Log Error about skipping the tables unregistration */
         m_AVD_LOG_INVALID_VAL_ERROR(tbl_id);
         rc = NCSCC_RC_FAILURE;
         continue;
      }
     
   } /* end for tbl_id loop. Un registration of all tables */

   return rc;
}



/****************************************************************************
  Name          : avd_mab_init
 
  Description   : This routine initializes MAB OAC. If active role
                  registers the tables.
 
  Arguments     : cb - ptr to the AVD control block
 
  Return Values : NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 
  Notes         : None.
******************************************************************************/
uns32 avd_mab_init (AVD_CL_CB *cb)
{

   m_AVD_LOG_FUNC_ENTRY("avd_mab_init");
   
   if (avd_mab_reg_tbls(cb) != NCSCC_RC_SUCCESS)
   {
      /* log error */
      m_AVD_LOG_INVALID_VAL_ERROR(NCSCC_RC_FAILURE);
      avd_mab_unreg_tbls(cb);
      return NCSCC_RC_FAILURE;
   }

   if (avd_mab_reg_rows(cb) != NCSCC_RC_SUCCESS)
   {
      /* log error */         
      m_AVD_LOG_INVALID_VAL_ERROR(NCSCC_RC_FAILURE);
      avd_mab_unreg_rows(cb);
      avd_mab_unreg_tbls(cb);
      return NCSCC_RC_FAILURE;
   }

   return NCSCC_RC_SUCCESS;
}




/*****************************************************************************
 * Function: avd_mab_reg_rows
 *
 * Purpose:  This function registers all AVD tables rows with MAB. 
 *
 * Input:    AVD Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * NOTES:None.
 *
 * 
 **************************************************************************/

uns32 avd_mab_reg_rows(AVD_CL_CB *cb)
{
   NCSOAC_SS_ARG            avd_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32 rc = NCSCC_RC_SUCCESS ;

   m_AVD_LOG_FUNC_ENTRY("avd_mab_reg_rows");
   
   /* Register for all tables rows*/
   m_NCS_MEMSET(&avd_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avd_oac_arg.i_oac_hdl = cb->mab_hdl;
   avd_oac_arg.i_op      = NCSOAC_SS_OP_ROW_OWNED;
   avd_oac_arg.info.row_owned.i_fltr.type = NCSMAB_FLTR_ANY;
   avd_oac_arg.info.row_owned.i_fltr.is_move_row_fltr = FALSE;
   avd_oac_arg.info.row_owned.i_ss_cb = (NCSOAC_SS_CB)NULL;
   avd_oac_arg.info.row_owned.i_ss_hdl = cb->cb_handle;

   for (tbl_id  = NCSMIB_TBL_AVSV_BASE;
        tbl_id <= NCSMIB_TBL_AVSV_AVD_END;
        tbl_id ++)
   {
      
      avd_oac_arg.i_tbl_id  = tbl_id;

      if(ncsoac_ss(&avd_oac_arg) != NCSCC_RC_SUCCESS)
      {
         /* Log Error about skipping the table rows */
         m_AVD_LOG_INVALID_VAL_ERROR(NCSCC_RC_FAILURE);
         rc = NCSCC_RC_FAILURE;
         continue;
      }

      cb->mab_row_hdl_list[tbl_id - NCSMIB_TBL_AVSV_BASE] =
                     avd_oac_arg.info.row_owned.o_row_hdl;
     m_AVD_LOG_RCVD_VAL(((uns32) avd_oac_arg.info.row_owned.o_row_hdl));
   } /* end for tbl_id loop. Registration of all tables rows */

   return rc;
}


/*****************************************************************************
 * Function: avd_mab_unreg_rows
 *
 * Purpose:  This function unregisters all AVD tables rows with MAB. 
 *
 * Input:    AVD Control Block. 
 *
 * Returns:  NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 *
 * NOTES:None.
 *
 * 
 **************************************************************************/

uns32 avd_mab_unreg_rows(AVD_CL_CB *cb)
{
   NCSOAC_SS_ARG            avd_oac_arg;
   NCSMIB_TBL_ID            tbl_id;
   uns32 rc = NCSCC_RC_SUCCESS ;

   m_AVD_LOG_FUNC_ENTRY("avd_mab_unreg_rows");
   
   /* Register for all tables */
   m_NCS_MEMSET(&avd_oac_arg, 0, sizeof(NCSOAC_SS_ARG));
 
   avd_oac_arg.i_oac_hdl = cb->mab_hdl;
   avd_oac_arg.i_op      = NCSOAC_SS_OP_ROW_GONE;

   for (tbl_id  = NCSMIB_TBL_AVSV_BASE;
        tbl_id <= NCSMIB_TBL_AVSV_AVD_END;
        tbl_id ++)
   {
      
      avd_oac_arg.i_tbl_id  = tbl_id;
      avd_oac_arg.info.row_gone.i_row_hdl = 
         cb->mab_row_hdl_list[tbl_id - NCSMIB_TBL_AVSV_BASE];

      if(ncsoac_ss(&avd_oac_arg) != NCSCC_RC_SUCCESS)
      {
         /* Log Error about skipping the table rows*/
         m_AVD_LOG_INVALID_VAL_ERROR(NCSCC_RC_FAILURE);
         rc = NCSCC_RC_FAILURE;
         continue;
      }
     
   } /* end for tbl_id loop. un registration of all tables rows */

   return rc;
}


/****************************************************************************
  Name          : avd_miblib_init
 
  Description   : This routine initializes MIBLIB module. It then
                  calls all the MIBLIB generated register routines for
                  all the MIB tables managed by AVD.
 
  Arguments     : cb - ptr to the AVD control block
 
  Return Values : NCSCC_RC_SUCCESS/NCSCC_RC_FAILURE
 
  Notes         : None.
******************************************************************************/
uns32 avd_miblib_init (AVD_CL_CB *cb)
{

   uns32              status = NCSCC_RC_SUCCESS; 
   NCSMIB_TBL_ID       tbl_id;  
   AVD_MIBLIB_REG_FUNC reg_func = NULL;
   
   m_AVD_LOG_FUNC_ENTRY("avd_miblib_init");

   for(tbl_id = NCSMIB_TBL_AVSV_BASE; 
       tbl_id <= NCSMIB_TBL_AVSV_AVD_END;
       tbl_id ++)
   {     
      /* Register the objects and table data with MIB lib */
      reg_func = avd_mib_reg_array[tbl_id - NCSMIB_TBL_AVSV_BASE];
      if(reg_func == NULL)
         continue;

      if(reg_func() != NCSCC_RC_SUCCESS)
      {
         /* Log error about skipping registering this table */
         m_AVD_LOG_INVALID_VAL_ERROR(tbl_id);
         status = NCSCC_RC_FAILURE;
         continue;
      }
      
   } /* End of for loop to register the tables */


   return status; 
}
