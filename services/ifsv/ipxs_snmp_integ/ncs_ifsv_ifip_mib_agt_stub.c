/*      -*- OpenSAF  -*-
 *
 * (C) Copyright 2008 The OpenSAF Foundation 
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY 
 * or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
 * under the GNU Lesser General Public License Version 2.1, February 1999.
 * The complete license can be accessed from the following location:
 * http://opensource.org/licenses/lgpl-license.php 
 * See the Copying file included with the OpenSAF distribution for full
 * licensing terms.
 *
 * Author(s): Emerson Network Power
 *   
 */


/*****************************************************************************
  MODULE NAME: NCS_IFSV_IFIP_MIB_AGT_STUB.C 
******************************************************************************/



/*
 * This C file has been generated by smidump 0.4.1.
 * It is intended to be used with the NET-SNMP agent library.
 *
 * This C file is derived from the NCS-IFSV-IFIP-MIB module.
 *
 * $Id$
 */

#include "ncs_ifsv_ifip_mib_agt_stub.h"

/**************************************************************************
  Definitions of tags that are used internally to read/write
  the selected object type. These tags should be unique.
***************************************************************************/


/*************** 'ncsIfsvIpEntry' table Definitions ***************/
#define NCSIFSVIPENTADDRTYPE             1
#define NCSIFSVIPENTADDR                 2
#define NCSIFSVIPENTADDRMASK             3
#define NCSIFSVIPENTIFINDEX              4
#define NCSIFSVIPENTROWSTATUS            5

static oid __ncs_ifsv_ip_entry_base[] = {1, 3, 6, 1, 4, 1, 161, 10, 1, 1, 2, 2, 1, 1};

static oid __ncs_ifsv_ip_table_base[] = {1, 3, 6, 1, 4, 1, 161, 10, 1, 1, 2, 2, 1};


/* Pl. note that this array should not have index objects, obsolete objects */
static unsigned int __ncs_ifsv_ip_table_valid_columns[] = {3, 4, 5};

static netsnmp_table_registration_info  *__ncsIfsvIpTable_tbl_info;
Netsnmp_Node_Handler                    __ncs_ifsv_ip_table_handler;
static netsnmp_handler_registration     *__ncsIfsvIpTable_reg;
static u_char __ncs_ifsv_ip_table_validate_set_varbinds(int colnum,
                                       netsnmp_request_info *cur_req);

struct variable  __ncs_ifsv_ip_entry_variables[] = {
              { NCSIFSVIPENTADDRTYPE, ASN_INTEGER, NOACCESS, 0, 0, {0} },
              { NCSIFSVIPENTADDR, ASN_IPADDRESS, NOACCESS, 0, 0, {0} },
              { NCSIFSVIPENTADDRMASK, ASN_INTEGER, RWRITE, 0, 0, {0} },
              { NCSIFSVIPENTIFINDEX, ASN_INTEGER, RWRITE, 0, 0, {0} },
              { NCSIFSVIPENTROWSTATUS, ASN_INTEGER, RWRITE, 0, 0, {0} }
};


/*************** 'ncsIfsvIfIpEntry' table Definitions ***************/
#define NCSIFSVIFIPADDRCNT               1
#define NCSIFSVIFIPADDR                  2
#define NCSIFSVIFIPISV4UNNMBRD           3

static oid __ncs_ifsv_if_ip_entry_base[] = {1, 3, 6, 1, 4, 1, 161, 10, 1, 1, 2, 2, 2, 1};

static oid __ncs_ifsv_if_ip_table_base[] = {1, 3, 6, 1, 4, 1, 161, 10, 1, 1, 2, 2, 2};


/* Pl. note that this array should not have index objects, obsolete objects */
static unsigned int __ncs_ifsv_if_ip_table_valid_columns[] = {1, 2, 3};

static netsnmp_table_registration_info  *__ncsIfsvIfIpTable_tbl_info;
Netsnmp_Node_Handler                    __ncs_ifsv_if_ip_table_handler;
static netsnmp_handler_registration     *__ncsIfsvIfIpTable_reg;
static u_char __ncs_ifsv_if_ip_table_validate_set_varbinds(int colnum,
                                       netsnmp_request_info *cur_req);

struct variable  __ncs_ifsv_if_ip_entry_variables[] = {
              { NCSIFSVIFIPADDRCNT, ASN_INTEGER, RONLY, 0, 0, {0} },
              { NCSIFSVIFIPADDR, ASN_OCTET_STR, RONLY, 0, 0, {0} },
              { NCSIFSVIFIPISV4UNNMBRD, ASN_INTEGER, RWRITE, 0, 0, {0} }
};



/****************************************************************************
  Registration & De-registration functions for the various MIB groups.
****************************************************************************/

/* Register function for the table: ncsIfsvIpEntry */
static int __register_ncs_ifsv_ip_entry()
{
   int       snmp_err  = SNMPERR_GENERR;
   uns32     status    = NCSCC_RC_FAILURE;
   uns32     var_count = sizeof(__ncs_ifsv_ip_entry_variables)/sizeof(struct variable);
   uns32     oid_len   = OID_LENGTH(__ncs_ifsv_ip_entry_base);
   NCSFL_MEM log_oid;
   uns32     base_oid_len = OID_LENGTH(__ncs_ifsv_ip_table_base);


   m_SNMPSUBAGT_GEN_STR("__register_ncs_ifsv_ip_entry()");


   __ncsIfsvIpTable_reg = netsnmp_create_handler_registration("ncsIfsvIpTable",
                                          __ncs_ifsv_ip_table_handler,
                                          __ncs_ifsv_ip_table_base,
                                          base_oid_len,
                                          HANDLER_CAN_RWRITE);
   if (__ncsIfsvIpTable_reg == NULL)
   {
      m_SNMPSUBAGT_GEN_STR("ncsIfsvIpTable: Create handler failed");
      return snmp_err;
   }

   __ncsIfsvIpTable_tbl_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
   if (__ncsIfsvIpTable_tbl_info == NULL)
   {
      m_SNMPSUBAGT_GEN_STR("ncsIfsvIpTable: Malloc for table info failed");
      /* free __ncsIfsvIpTable_reg */
      /* a void function */
      netsnmp_handler_registration_free(__ncsIfsvIpTable_reg);
      __ncsIfsvIpTable_reg = NULL;
      return snmp_err;
   }

   /* following is void function provided by the NET-SNMP library */
   netsnmp_table_helper_add_indexes(__ncsIfsvIpTable_tbl_info, ASN_INTEGER, ASN_IPADDRESS, 0);

   /* NOTE: for SMIDUMP
   If one of the indices of a table is a fixed length string, then let SMIDUMP generate
   the following code. This is because, this API does not take the length of the octet
   string. To avoid any changes to the API, let SMIDUMP generate,
   netsnmp_table_helper_add_indexes(__ncsIfsvIpTable_tbl_info,
                                    ASN_PRIV_IMPLIED_OCTET_STR, 0);
   Same as for a fixed length  OID type of index, it would be
   netsnmp_table_helper_add_indexes(__ncsIfsvIpTable_tbl_info,
                                    ASN_PRIV_IMPLIED_OBJECT_ID, 0);
   If a table has variable length strings for eg str1, str2(1..10), int, str3(1..10),
   then SMIDUMP would dump the following line.
   netsnmp_table_helper_add_indexes(__ncsIfsvIpTable_tbl_info, ASN_OCTET_STR,
                               ASN_OCTET_STR, ASN_INTEGER, ASN_OCTET_STR,0);
   */
   __ncsIfsvIpTable_tbl_info->min_column = NCSIFSVIPENTADDRMASK;
   __ncsIfsvIpTable_tbl_info->max_column = NCSIFSVIPENTROWSTATUS;

   /* build the valid columns */
   __ncsIfsvIpTable_tbl_info->valid_columns = (netsnmp_column_info*) malloc(sizeof(netsnmp_column_info));
   if (__ncsIfsvIpTable_tbl_info->valid_columns == NULL)
   {
      /* without this, we can not support SNMP GETNEXT operation  */
      m_SNMPSUBAGT_GEN_STR("ncsIfsvIpTable: malloc for valid columns failed"); 
      netsnmp_handler_registration_free(__ncsIfsvIpTable_reg);
      __ncsIfsvIpTable_reg = NULL;
      SNMP_FREE(__ncsIfsvIpTable_tbl_info);
      return snmp_err;
   }

   memset(__ncsIfsvIpTable_tbl_info->valid_columns, 0,
          sizeof(netsnmp_column_info));

   __ncsIfsvIpTable_tbl_info->valid_columns->isRange = 0;
   __ncsIfsvIpTable_tbl_info->valid_columns->list_count =
                 sizeof(__ncs_ifsv_ip_table_valid_columns)/sizeof(unsigned int);
   __ncsIfsvIpTable_tbl_info->valid_columns->details.list = __ncs_ifsv_ip_table_valid_columns;

   /* register the handler with library, and the table with the Agent */
   snmp_err = netsnmp_register_table(__ncsIfsvIpTable_reg, __ncsIfsvIpTable_tbl_info);
   if (snmp_err != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table: Registration failed", snmp_err);

      /* free the table details */
      free(__ncsIfsvIpTable_tbl_info->valid_columns);

      /* free the index columns */
      snmp_free_varbind(__ncsIfsvIpTable_tbl_info->indexes);

      /* free the node */
      SNMP_FREE(__ncsIfsvIpTable_tbl_info);
      __ncsIfsvIpTable_reg = NULL;
      return snmp_err;
   }

   m_SNMPSUBAGT_GEN_STR("ncsIfsvIpTable: Registered");

   memset(&log_oid, 0, sizeof(NCSFL_MEM));
   log_oid.len = sizeof(__ncs_ifsv_ip_table_base);
   log_oid.addr = log_oid.dump = (char*)__ncs_ifsv_ip_table_base;
   m_SNMPSUBAGT_GEN_OID_LOG(log_oid);

   /* Adds the tableId to the (TABLE/TRAP ID) patricia tree */
   status = snmpsubagt_table_oid_add(NCSMIB_TBL_IPXS_IPTBL,
                                     __ncs_ifsv_ip_entry_base,
                                     oid_len,
                                     __ncs_ifsv_ip_entry_variables,
                                     var_count);
   if (status != NCSCC_RC_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_table_oid_add(): failed", status);
      return SNMPERR_GENERR;
   }

   return snmp_err;
}



int __ncs_ifsv_ip_table_handler(netsnmp_mib_handler          *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
   netsnmp_request_info       *cur_req = NULL;
   netsnmp_table_request_info *table_info = NULL;
   netsnmp_variable_list      *var = NULL;
   NCSMIB_PARAM_VAL l_rsp_param_val;
   NCSMIB_ARG       mib_arg;
   NCSMIB_OP        req_type;
   NCSMEM_AID       ma;
   uns8     space[1024];
   u_char   *val_str = NULL; 
   size_t   val_len = 0;
   u_char   type = 0;
   u_char   error = 0;
   uns32    instance[MAX_OID_LEN] = {0};
   uns32    index = 0;
   uns32    status = NCSCC_RC_FAILURE;

   m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler(): Start.");

   for (cur_req = requests; cur_req; cur_req = cur_req->next)
   {
      if (cur_req->processed != 0)
          continue;

      /* get the table information/details given by the table helper */
      table_info = netsnmp_extract_table_info(cur_req);
      if (table_info == NULL)
         continue;

      var = cur_req->requestvb;
      /* clean the MIBARG vehicle */
      type = 0;
      val_str = NULL; 
      val_len = 0; 

      m_NCS_OS_MEMSET(&mib_arg, 0, sizeof(NCSMIB_ARG));
      m_NCS_OS_MEMSET(space, 0, sizeof(space));
      ncsmem_aid_init(&ma, space, 1024);

      /* compose the index */
      m_NCS_OS_MEMSET(instance, 0, (MAX_OID_LEN*sizeof(uns32)));
      for (index = 0; index < table_info->index_oid_len; index++)
         instance[index] = (uns32)table_info->index_oid[index];

      switch (reqinfo->mode)
      {
      case MODE_GET:
      case MODE_GETNEXT:
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler(): Got GET/GETNEXT request");

          if (var->type == ASN_NULL)
          {
             if (table_info->colnum == NCSIFSVIPENTADDRTYPE
                || table_info->colnum == NCSIFSVIPENTADDR)
             {
                netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOACCESS);
                continue;
             }

             if (reqinfo->mode == MODE_GET)
             {
                req_type = NCSMIB_OP_REQ_GET;
                m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler(): Got GET request");
             }
             else
             {
                req_type = NCSMIB_OP_REQ_NEXT;
                m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler(): Got GETNEXT request");
             }

             /* send the message to MAC */
             status = snmpsubagt_mab_mac_msg_send(&mib_arg, NCSMIB_TBL_IPXS_IPTBL,
                                               instance, table_info->index_oid_len,
                                               table_info->colnum,
                                               0/* type */, req_type, NULL, 0,
                                               NCS_SNMPSUBAGT_MAC_TIMEOUT, &ma, space, 1024,
                                               __ncs_ifsv_ip_entry_variables, sizeof(__ncs_ifsv_ip_entry_variables)/sizeof(struct variable),
                                             FALSE);
             if (status != NCSCC_RC_SUCCESS)
             {
                m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mac_msg_send() failed", status);
                if (reqinfo->mode == MODE_GETNEXT)
                  netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOERROR);
                else

                netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
                continue;
             }

             /* process the status of the MIB request */
             if (mib_arg.rsp.i_status != NCSCC_RC_SUCCESS)
             {
                m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mac_msg_send():error code from Appn:",mib_arg.rsp.i_status);

                /* set the error and continue */
                if(reqinfo->mode == MODE_GETNEXT)
                  netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOERROR);
                else
                  netsnmp_set_request_error(reqinfo, cur_req,
                             snmpsubagt_mab_error_code_map(mib_arg.rsp.i_status, reqinfo->mode));
                continue;
             }

           if (reqinfo->mode == MODE_GET)
             {
                 m_NCS_OS_MEMSET(&l_rsp_param_val, 0, sizeof(NCSMIB_PARAM_VAL));
                 m_NCS_OS_MEMCPY(&l_rsp_param_val,
                                 &mib_arg.rsp.info.get_rsp.i_param_val,
                                 sizeof(NCSMIB_PARAM_VAL));
             }
             else /* FOR GETNEXT */
             {
                m_NCS_OS_MEMSET(&l_rsp_param_val, 0, sizeof(NCSMIB_PARAM_VAL));
                m_NCS_OS_MEMCPY(&l_rsp_param_val,
                                &mib_arg.rsp.info.next_rsp.i_param_val,
                                sizeof(NCSMIB_PARAM_VAL));

                /* compose the OID with the new instance */
                status = snmpsubagt_mab_oid_compose(cur_req->requestvb->name,
                                                    &cur_req->requestvb->name_length,
                                                    __ncs_ifsv_ip_entry_base,
                                                    OID_LENGTH(__ncs_ifsv_ip_entry_base),
                                                    &mib_arg.rsp.info.next_rsp);
                if (status != NCSCC_RC_SUCCESS)
                {
                   m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_oid_compose() failed", status);
                   netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
                   continue;
                }
             } /* for GETNEXT */

             /* assign the type of the object */ 
             switch (l_rsp_param_val.i_param_id)
             {
                /* repeat the same case for all the objects in this table */
             case NCSIFSVIPENTADDRMASK:
                 type = ASN_INTEGER;
                 break;

             case NCSIFSVIPENTIFINDEX:
                 type = ASN_INTEGER;
                 break;

             case NCSIFSVIPENTROWSTATUS:
                 type = ASN_INTEGER;
                 break;

             default:
                 /* set the error code, and continue to the next varbind */
                 if ((reqinfo->mode == MODE_SET_RESERVE1) || (reqinfo->mode == MODE_SET_ACTION))
                    netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOTWRITABLE);
                 else
                    netsnmp_set_request_error(reqinfo, cur_req, SNMP_NOSUCHOBJECT);
                 continue;
                 break;
             }/* switch (table_info->colnum) */

           /* update the result */
             val_str  = snmpsubagt_mab_mibarg_resp_process(&l_rsp_param_val,
                                                           &val_len, type);
             if (val_str == NULL)
             {
                /* set the error code and continue to the next PDU */ 
                m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mibarg_resp_process():error (type from Appn)", l_rsp_param_val.i_fmat_id);
                netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
                continue;
             }

           /* upload the response from application to the varbind */ 
             if (snmp_set_var_typed_value(var, type, val_str, val_len) != 0)
             {
                /* set the error code and continue to the next PDU */
                m_SNMPSUBAGT_GEN_STR("snmp_set_var_typed_value(): failed");
                continue;
             }
          }/* end if (var->type == ASN_NULL) */
          break; /* MODE_GET/GETNEXT */

      case MODE_SET_RESERVE1:
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler(): Got RESERVE1 request");

          /* validate the type, length of the value to be set, and the value to be set */
          error = __ncs_ifsv_ip_table_validate_set_varbinds(table_info->colnum, cur_req);
          if (error != SNMP_ERR_NOERROR)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:__ncs_ifsv_ip_table_validate_set_varbinds(): failed with error code", error);
             /* set the error code and return */
             netsnmp_set_request_error(reqinfo, cur_req, error);
             continue;
          }

          /* send the TEST request */
          status = snmpsubagt_mab_mac_msg_send(&mib_arg, NCSMIB_TBL_IPXS_IPTBL,
                                               instance, table_info->index_oid_len, table_info->colnum,
                                               cur_req->requestvb->type,
                                               NCSMIB_OP_REQ_TEST,
                                               (void*)cur_req->requestvb->val.string, cur_req->requestvb->val_len,
                                               NCS_SNMPSUBAGT_MAC_TIMEOUT, &ma, space, 1024,
                                               __ncs_ifsv_ip_entry_variables, sizeof(__ncs_ifsv_ip_entry_variables)/sizeof(struct variable),
                                             FALSE);
          if (status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mac_msg_send()[TEST Req] failed", status);
             netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
             continue;
          }

          /* process the status of the MIB request */
          if (mib_arg.rsp.i_status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mac_msg_send()[TEST Req]:error code from Appn", mib_arg.rsp.i_status);
             netsnmp_set_request_error(reqinfo, cur_req,
                            snmpsubagt_mab_error_code_map(mib_arg.rsp.i_status, reqinfo->mode));
             continue;
          }
          break;

      case MODE_SET_RESERVE2:
          /* allocate memory, if any.  We do not support this */
          continue;
          break;

      case MODE_SET_ACTION:
          /* Send the SET request */
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler():got ACTION request");
          status = snmpsubagt_mab_mac_msg_send(&mib_arg, NCSMIB_TBL_IPXS_IPTBL,
                             instance, table_info->index_oid_len, table_info->colnum,
                             cur_req->requestvb->type,
                             NCSMIB_OP_REQ_SET,
                             (void*)cur_req->requestvb->val.string, cur_req->requestvb->val_len,
                             NCS_SNMPSUBAGT_MAC_TIMEOUT, &ma, space, 1024,
                             __ncs_ifsv_ip_entry_variables, sizeof(__ncs_ifsv_ip_entry_variables)/sizeof(struct variable), 
                                             FALSE);
          if (status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mac_msg_send()[SET Req] failed", status);
             netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
             continue;
          }

          /* process the status of the MIB request */
          if (mib_arg.rsp.i_status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:snmpsubagt_mab_mac_msg_send()[SET Req]:error code from Appn", mib_arg.rsp.i_status);
             netsnmp_set_request_error(reqinfo, cur_req,
                           snmpsubagt_mab_error_code_map(mib_arg.rsp.i_status, reqinfo->mode));
             continue;
          }
          break;

      case MODE_SET_FREE:
          /** Forget undo data, if exists */
         m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler():got FREE request");
          continue;
          break;

      case MODE_SET_COMMIT:
          /** Forget undo data, if exists */
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler():got COMMIT request");
          continue;
          break;

      case MODE_SET_UNDO:
          /** Forget undo data, if exists */
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler(): Got UNDO request");
          continue;
          break;

      default:
         m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_handler():got UNKNOWN request");
          break;
      }/* end of switch */
   }/* end of  for(cur_req) */

   return SNMP_ERR_NOERROR;
}/* end __ncs_ifsv_ip_table_handler() */

static u_char __ncs_ifsv_ip_table_validate_set_varbinds(int colnum,
                                            netsnmp_request_info *cur_req)
{
   u_char  snmp_err = SNMP_ERR_NOERROR;

   m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_ip_table_validate_set_varbinds()");

   switch (colnum)
   {
   /* NOTE: No verification against the values is not done, since there is no
    * mention about the range in the MIB definition.
    */
   case NCSIFSVIPENTADDRTYPE:
       snmp_err = SNMP_ERR_NOTWRITABLE;
       break;

   /* NOTE: No verification against the values is not done, since there is no
    * mention about the range in the MIB definition.
    */
   case NCSIFSVIPENTADDR:
       snmp_err = SNMP_ERR_NOTWRITABLE;
       break;

   case NCSIFSVIPENTADDRMASK:
       /* Validate the type */
       if (cur_req->requestvb->type != ASN_INTEGER)
       {
          snmp_err = SNMP_ERR_WRONGTYPE;
          break;
       }

       /* validate the value length */
       if (cur_req->requestvb->val_len != sizeof(long))
       {
          snmp_err = SNMP_ERR_WRONGLENGTH;
          break;
       }
       break;

   case NCSIFSVIPENTIFINDEX:
       /* Validate the type */
       if (cur_req->requestvb->type != ASN_INTEGER)
       {
          snmp_err = SNMP_ERR_WRONGTYPE;
          break;
       }

       /* validate the value length */
       if (cur_req->requestvb->val_len != sizeof(long))
       {
          snmp_err = SNMP_ERR_WRONGLENGTH;
          break;
       }
       if ((*((long*)cur_req->requestvb->val.string) < 1) ||
           (*((long*)cur_req->requestvb->val.string) > 2147483647))
       {
          snmp_err = SNMP_ERR_WRONGVALUE;
          break;
       }
       break;

   case NCSIFSVIPENTROWSTATUS:
       /* Validate the type */
       if (cur_req->requestvb->type != ASN_INTEGER)
       {
          snmp_err = SNMP_ERR_WRONGTYPE;
          break;
       }

       /* validate the value length */
       if (cur_req->requestvb->val_len != sizeof(long))
       {
          snmp_err = SNMP_ERR_WRONGLENGTH;
          break;
       }
       break;

   default:
       snmp_err = SNMP_ERR_NOTWRITABLE;
       break;
   }

   return snmp_err;
}

/* De-register function for the table: ncsIfsvIpEntry */
static int  __unregister_ncs_ifsv_ip_entry()
{
   uns32 status   = NCSCC_RC_FAILURE;
   int   snmp_err = SNMPERR_GENERR;
   NCSFL_MEM    log_oid;

   m_SNMPSUBAGT_GEN_STR("__unregister_ncs_ifsv_ip_entry()");

   snmp_err =  snmpsubagt_mab_unregister_mib(__ncsIfsvIpTable_reg);
   if (snmp_err != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_table:__unregister_ncs_ifsv_ip_entry(): failed with error code", snmp_err);
   }
   __ncsIfsvIpTable_reg = NULL;
   m_SNMPSUBAGT_GEN_STR("ncsIfsvIpEntry: UnRegistered");

   memset(&log_oid, 0, sizeof(NCSFL_MEM));
   log_oid.len = sizeof(__ncs_ifsv_ip_table_base);
   log_oid.addr = log_oid.dump = (char*)__ncs_ifsv_ip_table_base;

   m_SNMPSUBAGT_GEN_OID_LOG(log_oid);

   /* free the table details */
   free(__ncsIfsvIpTable_tbl_info->valid_columns);

   /* free the index columns */
   snmp_free_varbind(__ncsIfsvIpTable_tbl_info->indexes);

   /* free the node */
   SNMP_FREE(__ncsIfsvIpTable_tbl_info);
   /* Deletes the tableId from the (TABLE/TRAP ID) patricia tree */
   status = snmpsubagt_table_oid_del(NCSMIB_TBL_IPXS_IPTBL);
   if (status != NCSCC_RC_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_entry:snmpsubagt_table_oid_del(): failed", status);
      return SNMPERR_GENERR;
   }

   return snmp_err;
}



/* Register function for the table: ncsIfsvIfIpEntry */
static int __register_ncs_ifsv_if_ip_entry()
{
   int       snmp_err  = SNMPERR_GENERR;
   uns32     status    = NCSCC_RC_FAILURE;
   uns32     var_count = sizeof(__ncs_ifsv_if_ip_entry_variables)/sizeof(struct variable);
   uns32     oid_len   = OID_LENGTH(__ncs_ifsv_if_ip_entry_base);
   NCSFL_MEM log_oid;
   uns32     base_oid_len = OID_LENGTH(__ncs_ifsv_if_ip_table_base);


   m_SNMPSUBAGT_GEN_STR("__register_ncs_ifsv_if_ip_entry()");


   __ncsIfsvIfIpTable_reg = netsnmp_create_handler_registration("ncsIfsvIfIpTable",
                                          __ncs_ifsv_if_ip_table_handler,
                                          __ncs_ifsv_if_ip_table_base,
                                          base_oid_len,
                                          HANDLER_CAN_RWRITE);
   if (__ncsIfsvIfIpTable_reg == NULL)
   {
      m_SNMPSUBAGT_GEN_STR("ncsIfsvIfIpTable: Create handler failed");
      return snmp_err;
   }

   __ncsIfsvIfIpTable_tbl_info = SNMP_MALLOC_TYPEDEF(netsnmp_table_registration_info);
   if (__ncsIfsvIfIpTable_tbl_info == NULL)
   {
      m_SNMPSUBAGT_GEN_STR("ncsIfsvIfIpTable: Malloc for table info failed");
      /* free __ncsIfsvIfIpTable_reg */
      /* a void function */
      netsnmp_handler_registration_free(__ncsIfsvIfIpTable_reg);
      __ncsIfsvIfIpTable_reg = NULL;
      return snmp_err;
   }

   /* following is void function provided by the NET-SNMP library */
   netsnmp_table_helper_add_indexes(__ncsIfsvIfIpTable_tbl_info, ASN_PRIV_IMPLIED_OCTET_STR, 0);

   /* NOTE: for SMIDUMP
   If one of the indices of a table is a fixed length string, then let SMIDUMP generate
   the following code. This is because, this API does not take the length of the octet
   string. To avoid any changes to the API, let SMIDUMP generate,
   netsnmp_table_helper_add_indexes(__ncsIfsvIfIpTable_tbl_info,
                                    ASN_PRIV_IMPLIED_OCTET_STR, 0);
   Same as for a fixed length  OID type of index, it would be
   netsnmp_table_helper_add_indexes(__ncsIfsvIfIpTable_tbl_info,
                                    ASN_PRIV_IMPLIED_OBJECT_ID, 0);
   If a table has variable length strings for eg str1, str2(1..10), int, str3(1..10),
   then SMIDUMP would dump the following line.
   netsnmp_table_helper_add_indexes(__ncsIfsvIfIpTable_tbl_info, ASN_OCTET_STR,
                               ASN_OCTET_STR, ASN_INTEGER, ASN_OCTET_STR,0);
   */
   __ncsIfsvIfIpTable_tbl_info->min_column = NCSIFSVIFIPADDRCNT;
   __ncsIfsvIfIpTable_tbl_info->max_column = NCSIFSVIFIPISV4UNNMBRD;

   /* build the valid columns */
   __ncsIfsvIfIpTable_tbl_info->valid_columns = (netsnmp_column_info*) malloc(sizeof(netsnmp_column_info));
   if (__ncsIfsvIfIpTable_tbl_info->valid_columns == NULL)
   {
      /* without this, we can not support SNMP GETNEXT operation  */
      m_SNMPSUBAGT_GEN_STR("ncsIfsvIfIpTable: malloc for valid columns failed"); 
      netsnmp_handler_registration_free(__ncsIfsvIfIpTable_reg);
      __ncsIfsvIfIpTable_reg = NULL;
      SNMP_FREE(__ncsIfsvIfIpTable_tbl_info);
      return snmp_err;
   }

   memset(__ncsIfsvIfIpTable_tbl_info->valid_columns, 0,
          sizeof(netsnmp_column_info));

   __ncsIfsvIfIpTable_tbl_info->valid_columns->isRange = 0;
   __ncsIfsvIfIpTable_tbl_info->valid_columns->list_count =
                 sizeof(__ncs_ifsv_if_ip_table_valid_columns)/sizeof(unsigned int);
   __ncsIfsvIfIpTable_tbl_info->valid_columns->details.list = __ncs_ifsv_if_ip_table_valid_columns;

   /* register the handler with library, and the table with the Agent */
   snmp_err = netsnmp_register_table(__ncsIfsvIfIpTable_reg, __ncsIfsvIfIpTable_tbl_info);
   if (snmp_err != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table: Registration failed", snmp_err);

      /* free the table details */
      free(__ncsIfsvIfIpTable_tbl_info->valid_columns);

      /* free the index columns */
      snmp_free_varbind(__ncsIfsvIfIpTable_tbl_info->indexes);

      /* free the node */
      SNMP_FREE(__ncsIfsvIfIpTable_tbl_info);
      __ncsIfsvIfIpTable_reg = NULL;
      return snmp_err;
   }

   m_SNMPSUBAGT_GEN_STR("ncsIfsvIfIpTable: Registered");

   memset(&log_oid, 0, sizeof(NCSFL_MEM));
   log_oid.len = sizeof(__ncs_ifsv_if_ip_table_base);
   log_oid.addr = log_oid.dump = (char*)__ncs_ifsv_if_ip_table_base;
   m_SNMPSUBAGT_GEN_OID_LOG(log_oid);

   /* Adds the tableId to the (TABLE/TRAP ID) patricia tree */
   status = snmpsubagt_table_oid_add(NCSMIB_TBL_IPXS_IFIPTBL,
                                     __ncs_ifsv_if_ip_entry_base,
                                     oid_len,
                                     __ncs_ifsv_if_ip_entry_variables,
                                     var_count);
   if (status != NCSCC_RC_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_table_oid_add(): failed", status);
      return SNMPERR_GENERR;
   }

   return snmp_err;
}



int __ncs_ifsv_if_ip_table_handler(netsnmp_mib_handler          *handler,
                               netsnmp_handler_registration *reginfo,
                               netsnmp_agent_request_info   *reqinfo,
                               netsnmp_request_info         *requests)
{
   netsnmp_request_info       *cur_req = NULL;
   netsnmp_table_request_info *table_info = NULL;
   netsnmp_variable_list      *var = NULL;
   NCSMIB_PARAM_VAL l_rsp_param_val;
   NCSMIB_ARG       mib_arg;
   NCSMIB_OP        req_type;
   NCSMEM_AID       ma;
   uns8     space[1024];
   u_char   *val_str = NULL; 
   size_t   val_len = 0;
   u_char   type = 0;
   u_char   error = 0;
   uns32    instance[MAX_OID_LEN] = {0};
   uns32    index = 0;
   uns32    status = NCSCC_RC_FAILURE;

   m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler(): Start.");

   for (cur_req = requests; cur_req; cur_req = cur_req->next)
   {
      if (cur_req->processed != 0)
          continue;

      /* get the table information/details given by the table helper */
      table_info = netsnmp_extract_table_info(cur_req);
      if (table_info == NULL)
         continue;

      var = cur_req->requestvb;
      /* clean the MIBARG vehicle */
      type = 0;
      val_str = NULL; 
      val_len = 0; 

      m_NCS_OS_MEMSET(&mib_arg, 0, sizeof(NCSMIB_ARG));
      m_NCS_OS_MEMSET(space, 0, sizeof(space));
      ncsmem_aid_init(&ma, space, 1024);

      /* compose the index */
      m_NCS_OS_MEMSET(instance, 0, (MAX_OID_LEN*sizeof(uns32)));
      for (index = 0; index < table_info->index_oid_len; index++)
         instance[index] = (uns32)table_info->index_oid[index];

      switch (reqinfo->mode)
      {
      case MODE_GET:
      case MODE_GETNEXT:
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler(): Got GET/GETNEXT request");

          if (var->type == ASN_NULL)
          {

             if (reqinfo->mode == MODE_GET)
             {
                req_type = NCSMIB_OP_REQ_GET;
                m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler(): Got GET request");
             }
             else
             {
                req_type = NCSMIB_OP_REQ_NEXT;
                m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler(): Got GETNEXT request");
             }

             /* send the message to MAC */
             status = snmpsubagt_mab_mac_msg_send(&mib_arg, NCSMIB_TBL_IPXS_IFIPTBL,
                                               instance, table_info->index_oid_len,
                                               table_info->colnum,
                                               0/* type */, req_type, NULL, 0,
                                               NCS_SNMPSUBAGT_MAC_TIMEOUT, &ma, space, 1024,
                                               __ncs_ifsv_if_ip_entry_variables, sizeof(__ncs_ifsv_if_ip_entry_variables)/sizeof(struct variable),
                                             FALSE);
             if (status != NCSCC_RC_SUCCESS)
             {
                m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mac_msg_send() failed", status);
                if (reqinfo->mode == MODE_GETNEXT)
                  netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOERROR);
                else

                netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
                continue;
             }

             /* process the status of the MIB request */
             if (mib_arg.rsp.i_status != NCSCC_RC_SUCCESS)
             {
                m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mac_msg_send():error code from Appn:",mib_arg.rsp.i_status);

                /* set the error and continue */
                if(reqinfo->mode == MODE_GETNEXT)
                  netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOERROR);
                else
                  netsnmp_set_request_error(reqinfo, cur_req,
                             snmpsubagt_mab_error_code_map(mib_arg.rsp.i_status, reqinfo->mode));
                continue;
             }

           if (reqinfo->mode == MODE_GET)
             {
                 m_NCS_OS_MEMSET(&l_rsp_param_val, 0, sizeof(NCSMIB_PARAM_VAL));
                 m_NCS_OS_MEMCPY(&l_rsp_param_val,
                                 &mib_arg.rsp.info.get_rsp.i_param_val,
                                 sizeof(NCSMIB_PARAM_VAL));
             }
             else /* FOR GETNEXT */
             {
                m_NCS_OS_MEMSET(&l_rsp_param_val, 0, sizeof(NCSMIB_PARAM_VAL));
                m_NCS_OS_MEMCPY(&l_rsp_param_val,
                                &mib_arg.rsp.info.next_rsp.i_param_val,
                                sizeof(NCSMIB_PARAM_VAL));

                /* compose the OID with the new instance */
                status = snmpsubagt_mab_oid_compose(cur_req->requestvb->name,
                                                    &cur_req->requestvb->name_length,
                                                    __ncs_ifsv_if_ip_entry_base,
                                                    OID_LENGTH(__ncs_ifsv_if_ip_entry_base),
                                                    &mib_arg.rsp.info.next_rsp);
                if (status != NCSCC_RC_SUCCESS)
                {
                   m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_oid_compose() failed", status);
                   netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
                   continue;
                }
             } /* for GETNEXT */

             /* assign the type of the object */ 
             switch (l_rsp_param_val.i_param_id)
             {
                /* repeat the same case for all the objects in this table */
             case NCSIFSVIFIPADDRCNT:
                 type = ASN_INTEGER;
                 break;

             case NCSIFSVIFIPADDR:
                 type = ASN_OCTET_STR;
                 break;

             case NCSIFSVIFIPISV4UNNMBRD:
                 type = ASN_INTEGER;
                 break;

             default:
                 /* set the error code, and continue to the next varbind */
                 if ((reqinfo->mode == MODE_SET_RESERVE1) || (reqinfo->mode == MODE_SET_ACTION))
                    netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_NOTWRITABLE);
                 else
                    netsnmp_set_request_error(reqinfo, cur_req, SNMP_NOSUCHOBJECT);
                 continue;
                 break;
             }/* switch (table_info->colnum) */

           /* update the result */
             val_str  = snmpsubagt_mab_mibarg_resp_process(&l_rsp_param_val,
                                                           &val_len, type);
             if (val_str == NULL)
             {
                /* set the error code and continue to the next PDU */ 
                m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mibarg_resp_process():error (type from Appn)", l_rsp_param_val.i_fmat_id);
                netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
                continue;
             }

           /* upload the response from application to the varbind */ 
             if (snmp_set_var_typed_value(var, type, val_str, val_len) != 0)
             {
                /* set the error code and continue to the next PDU */
                m_SNMPSUBAGT_GEN_STR("snmp_set_var_typed_value(): failed");
                continue;
             }
          }/* end if (var->type == ASN_NULL) */
          break; /* MODE_GET/GETNEXT */

      case MODE_SET_RESERVE1:
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler(): Got RESERVE1 request");

          /* validate the type, length of the value to be set, and the value to be set */
          error = __ncs_ifsv_if_ip_table_validate_set_varbinds(table_info->colnum, cur_req);
          if (error != SNMP_ERR_NOERROR)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:__ncs_ifsv_if_ip_table_validate_set_varbinds(): failed with error code", error);
             /* set the error code and return */
             netsnmp_set_request_error(reqinfo, cur_req, error);
             continue;
          }

          /* send the TEST request */
          status = snmpsubagt_mab_mac_msg_send(&mib_arg, NCSMIB_TBL_IPXS_IFIPTBL,
                                               instance, table_info->index_oid_len, table_info->colnum,
                                               cur_req->requestvb->type,
                                               NCSMIB_OP_REQ_TEST,
                                               (void*)cur_req->requestvb->val.string, cur_req->requestvb->val_len,
                                               NCS_SNMPSUBAGT_MAC_TIMEOUT, &ma, space, 1024,
                                               __ncs_ifsv_if_ip_entry_variables, sizeof(__ncs_ifsv_if_ip_entry_variables)/sizeof(struct variable),
                                             FALSE);
          if (status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mac_msg_send()[TEST Req] failed", status);
             netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
             continue;
          }

          /* process the status of the MIB request */
          if (mib_arg.rsp.i_status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mac_msg_send()[TEST Req]:error code from Appn", mib_arg.rsp.i_status);
             netsnmp_set_request_error(reqinfo, cur_req,
                            snmpsubagt_mab_error_code_map(mib_arg.rsp.i_status, reqinfo->mode));
             continue;
          }
          break;

      case MODE_SET_RESERVE2:
          /* allocate memory, if any.  We do not support this */
          continue;
          break;

      case MODE_SET_ACTION:
          /* Send the SET request */
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler():got ACTION request");
          status = snmpsubagt_mab_mac_msg_send(&mib_arg, NCSMIB_TBL_IPXS_IFIPTBL,
                             instance, table_info->index_oid_len, table_info->colnum,
                             cur_req->requestvb->type,
                             NCSMIB_OP_REQ_SET,
                             (void*)cur_req->requestvb->val.string, cur_req->requestvb->val_len,
                             NCS_SNMPSUBAGT_MAC_TIMEOUT, &ma, space, 1024,
                             __ncs_ifsv_if_ip_entry_variables, sizeof(__ncs_ifsv_if_ip_entry_variables)/sizeof(struct variable), 
                                             FALSE);
          if (status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mac_msg_send()[SET Req] failed", status);
             netsnmp_set_request_error(reqinfo, cur_req, SNMP_ERR_GENERR);
             continue;
          }

          /* process the status of the MIB request */
          if (mib_arg.rsp.i_status != NCSCC_RC_SUCCESS)
          {
             m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:snmpsubagt_mab_mac_msg_send()[SET Req]:error code from Appn", mib_arg.rsp.i_status);
             netsnmp_set_request_error(reqinfo, cur_req,
                           snmpsubagt_mab_error_code_map(mib_arg.rsp.i_status, reqinfo->mode));
             continue;
          }
          break;

      case MODE_SET_FREE:
          /** Forget undo data, if exists */
         m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler():got FREE request");
          continue;
          break;

      case MODE_SET_COMMIT:
          /** Forget undo data, if exists */
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler():got COMMIT request");
          continue;
          break;

      case MODE_SET_UNDO:
          /** Forget undo data, if exists */
          m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler(): Got UNDO request");
          continue;
          break;

      default:
         m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_handler():got UNKNOWN request");
          break;
      }/* end of switch */
   }/* end of  for(cur_req) */

   return SNMP_ERR_NOERROR;
}/* end __ncs_ifsv_if_ip_table_handler() */

static u_char __ncs_ifsv_if_ip_table_validate_set_varbinds(int colnum,
                                            netsnmp_request_info *cur_req)
{
   u_char  snmp_err = SNMP_ERR_NOERROR;

   m_SNMPSUBAGT_GEN_STR("__ncs_ifsv_if_ip_table_validate_set_varbinds()");

   switch (colnum)
   {
   /* read-only object */
   case NCSIFSVIFIPADDRCNT:
       snmp_err = SNMP_ERR_NOTWRITABLE;

       break;

   /* read-only object */
   case NCSIFSVIFIPADDR:
       snmp_err = SNMP_ERR_NOTWRITABLE;

       break;

   case NCSIFSVIFIPISV4UNNMBRD:
       /* Validate the type */
       if (cur_req->requestvb->type != ASN_INTEGER)
       {
          snmp_err = SNMP_ERR_WRONGTYPE;
          break;
       }

       /* validate the value length */
       if (cur_req->requestvb->val_len != sizeof(long))
       {
          snmp_err = SNMP_ERR_WRONGLENGTH;
          break;
       }
       break;

   default:
       snmp_err = SNMP_ERR_NOTWRITABLE;
       break;
   }

   return snmp_err;
}

/* De-register function for the table: ncsIfsvIfIpEntry */
static int  __unregister_ncs_ifsv_if_ip_entry()
{
   uns32 status   = NCSCC_RC_FAILURE;
   int   snmp_err = SNMPERR_GENERR;
   NCSFL_MEM    log_oid;

   m_SNMPSUBAGT_GEN_STR("__unregister_ncs_ifsv_if_ip_entry()");

   snmp_err =  snmpsubagt_mab_unregister_mib(__ncsIfsvIfIpTable_reg);
   if (snmp_err != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_table:__unregister_ncs_ifsv_if_ip_entry(): failed with error code", snmp_err);
   }
   __ncsIfsvIfIpTable_reg = NULL;
   m_SNMPSUBAGT_GEN_STR("ncsIfsvIfIpEntry: UnRegistered");

   memset(&log_oid, 0, sizeof(NCSFL_MEM));
   log_oid.len = sizeof(__ncs_ifsv_if_ip_table_base);
   log_oid.addr = log_oid.dump = (char*)__ncs_ifsv_if_ip_table_base;

   m_SNMPSUBAGT_GEN_OID_LOG(log_oid);

   /* free the table details */
   free(__ncsIfsvIfIpTable_tbl_info->valid_columns);

   /* free the index columns */
   snmp_free_varbind(__ncsIfsvIfIpTable_tbl_info->indexes);

   /* free the node */
   SNMP_FREE(__ncsIfsvIfIpTable_tbl_info);
   /* Deletes the tableId from the (TABLE/TRAP ID) patricia tree */
   status = snmpsubagt_table_oid_del(NCSMIB_TBL_IPXS_IFIPTBL);
   if (status != NCSCC_RC_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_entry:snmpsubagt_table_oid_del(): failed", status);
      return SNMPERR_GENERR;
   }

   return snmp_err;
}



/**************************************************************************
Name          :  __register_ncs_ifsv_ifip_mib_module

Description   :  This function is a common registration routine where it
                 calls all the table registration routines of a module(MIB).

Arguments     :  - NIL -

Return values :  Nothing

Notes         :  Basically it registers the module (for all the TABLEs
                 defined the MIB) with SNMP agent
**************************************************************************/
uns32 __register_ncs_ifsv_ifip_mib_module()
{
   int   status = SNMPERR_SUCCESS;

   m_SNMPSUBAGT_GEN_STR("__register_ncs_ifsv_ifip_mib_module()");

   /* Calling the registration routine for  ncsIfsvIpEntry  table */
   status =  __register_ncs_ifsv_ip_entry();
   if (status != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_entry:__register_ncs_ifsv_ip_entry(): failed", status);
      return NCSCC_RC_FAILURE;
   }

   /* Calling the registration routine for  ncsIfsvIfIpEntry  table */
   status =  __register_ncs_ifsv_if_ip_entry();
   if (status != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_entry:__register_ncs_ifsv_if_ip_entry(): failed", status);
      return NCSCC_RC_FAILURE;
   }

   return NCSCC_RC_SUCCESS; 
}


/**************************************************************************
Name          :  __unregister_ncs_ifsv_ifip_mib_module

Description   :  This function is a common unregistration routine where it
                 calls all the table unregistration routines of a module(MIB).

Arguments     :  - NIL -

Return values :  Nothing

Notes         :  Basically it deregisters the module (for all the TABLEs
                 defined the MIB) with SNMP agent
**************************************************************************/
uns32 __unregister_ncs_ifsv_ifip_mib_module()
{
   int   status = SNMPERR_SUCCESS;

   m_SNMPSUBAGT_GEN_STR("__unregister_ncs_ifsv_ifip_mib_module()");

   /* Calling the de-registration routine for  ncsIfsvIpEntry  table */
   status =  __unregister_ncs_ifsv_ip_entry();
   if (status != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_ip_entry:__unregister_ncs_ifsv_ip_entry(): failed", status);
      return NCSCC_RC_FAILURE;
   }

   /* Calling the de-registration routine for  ncsIfsvIfIpEntry  table */
   status =  __unregister_ncs_ifsv_if_ip_entry();
   if (status != SNMPERR_SUCCESS)
   {
      m_SNMPSUBAGT_GEN_ERR("ncs_ifsv_if_ip_entry:__unregister_ncs_ifsv_if_ip_entry(): failed", status);
      return NCSCC_RC_FAILURE;
   }

   return NCSCC_RC_SUCCESS; 
}

