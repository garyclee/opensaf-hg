/*      -*- OpenSAF  -*-
 *
 * (C) Copyright 2008 The OpenSAF Foundation
 *
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE. This file and program are licensed
 * under the GNU Lesser General Public License Version 2.1, February 1999.
 * The complete license can be accessed from the following location:
 * http://opensource.org/licenses/lgpl-license.php
 * See the Copying file included with the OpenSAF distribution for full
 * licensing terms.
 *
 * Author(s): Emerson Network Power
 *
 */

/*****************************************************************************
..............................................................................



..............................................................................

  DESCRIPTION:This module contains the functions for accessing the scalar MIB  
  objects related to the AvD. It also contains the common function that is 
  called when a MIB related event occurs, This function does the sanity check
  and in turn calls the MIBLIB routine.

..............................................................................

  FUNCTIONS INCLUDED in this module:

  avsvscalars_get - This function is one of the get processing
                        routines for the scalar objects in AVSV_SCALARS_ID.
  avsvscalars_extract - This function is one of the get processing
                            function for the scalar objects in AVSV_SCALARS_ID.
  avsvscalars_set - This function is the set processing for scalar objects in
                         AVSV_SCALARS_ID.
  avsvscalars_next - This function is the next processing for scalar objects in
                         AVSV_SCALARS_ID. This is a dummy function as scalars
                         dont have next support.
  avsvscalars_setrow - This function is the setrow processing for
                           scalar objects in AVSV_SCALARS_ID. This is a dummy
                       function as scalars dont have setrow support.
  saamfscalars_get - This function is one of the get processing
                        routines for the scalar objects in SA_AMF_SCALARS_ID.
                        This is a dummy function as this table is not supported.
  saamfscalars_extract - This function is one of the get processing
                            function for the scalar objects in SA_AMF_SCALARS_ID.
                         This is a dummy function as this table is not supported.
  saamfscalars_set - This function is the set processing for scalar objects in
                         SA_AMF_SCALARS_ID.
                      This is a dummy function as this table is not supported.
  saamfscalars_next - This function is the next processing for scalar objects in
                         SA_AMF_SCALARS_ID. This is a dummy function as this
                         table is not supported.
  saamfscalars_setrow - This function is the setrow processing for
                           scalar objects in SA_AMF_SCALARS_ID. This is a 
                        dummy function as this table is not supported.
  safclmscalarobject_get - This function is one of the get processing
                        routines for the scalar objects in SAF_CLM_SCALAR_OBJECT_ID.
  safclmscalarobject_extract - This function is one of the get processing
                            function for the scalar objects in SAF_CLM_SCALAR_OBJECT_ID.
  safclmscalarobject_set - This function is the set processing for scalar objects in
                         SAF_CLM_SCALAR_OBJECT_ID. This is a dummy function as
                         this table dont have set support.
  safclmscalarobject_next - This function is the next processing for scalar objects in
                         SAF_CLM_SCALAR_OBJECT_ID. This is a dummy function as scalars
                         dont have next support.
  safclmscalarobject_setrow - This function is the setrow processing for
                           scalar objects in SAF_CLM_SCALAR_OBJECT_ID. This is a dummy
                       function as scalars dont have setrow support.
  avd_req_mib_func - MIB request event handler.


  
******************************************************************************
*/

/*
 * Module Inclusion Control...
 */

#include "avd.h"


/*****************************************************************************
 * Function: avsvscalars_get
 *
 * Purpose:  This function is the get processing routine for the 
 * scalar objects in AVSV_SCALARS_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function returns the pointer to the CB data structure which
 * contains all the scalar information.
 *
 * Input:  cb        - AVD control block.
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 * NOTES: This function works in conjunction with extract function to provide the
 * get functionality.
 *
 * 
 **************************************************************************/

uns32 avsvscalars_get(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                                  NCSCONTEXT* data)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)cb;

   if (avd_cb->cluster_admin_state != NCS_ADMIN_STATE_UNLOCK)
   {
      /* Invalid instance as the system is going down. */
      return NCSCC_RC_NO_INSTANCE;  
   }

   /* Fill the cb pointer to the data field and return */
   *data = (NCSCONTEXT)avd_cb;
   
   return NCSCC_RC_SUCCESS;
}

/*****************************************************************************
 * Function: avsvscalars_extract
 *
 * Purpose:  This function is the get processing function for scalar objects in
 * AVSV_SCALARS_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after calling the get call to get data structure.
 * This function fills the value information in the param filed structure. For
 * octate information the buffer field will be used for filling the information.
 * MIBLIB will provide the memory and pointer to the buffer. For only objects that
 * have a direct value(i.e their offset is not 0 in VAR INFO) in the structure
 * the data field is filled using the VAR INFO provided by MIBLIB, for others based
 * on the OID the value is filled accordingly.
 *
 * Input:  param     -  param->i_param_id indicates the parameter to extract
 *                      The remaining elements of the param need to be filled
 *                      by the subystem's extract function
 *         var_info  - Pointer to the var_info structure for the param.
 *         data      - The pointer to the data-structure containing the object
 *                     value which we have already provided to MIBLIB from get call.
 *         buffer    - The buffer pointer provided by MIBLIB for filling the octate
 *                     type data.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 *
 * NOTES:  This function works in conjunction with other functions to provide the
 * get functionality.
 *
 * 
 **************************************************************************/

uns32 avsvscalars_extract(NCSMIB_PARAM_VAL* param, 
                              NCSMIB_VAR_INFO* var_info, NCSCONTEXT data,
                              NCSCONTEXT buffer)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)data;
   
   if (avd_cb == AVD_CL_CB_NULL)
   {
      /* The row was not found */
      return NCSCC_RC_NO_INSTANCE;
   }

   switch(param->i_param_id)
   {
   case ncsAvDHeartbeatSendInt_ID:
      m_AVSV_UNS64_TO_PARAM(param,buffer,avd_cb->snd_hb_intvl);
      break;
   case ncsAvDHeartbeatDownInt_ID:
      m_AVSV_UNS64_TO_PARAM(param,buffer,avd_cb->rcv_hb_intvl);
      break;
   case ncsCLViewNumber_ID:
      m_AVSV_UNS64_TO_PARAM(param,buffer,avd_cb->cluster_view_number);
      break;
   default:
      /* call the MIBLIB utility routine for standard object types */
      if ((var_info != NULL) && (var_info->offset != 0))
         return ncsmiblib_get_obj_val(param, var_info, data, buffer);
      else
         return NCSCC_RC_NO_OBJECT;
      break;
   }
   return NCSCC_RC_SUCCESS;
}


/*****************************************************************************
 * Function: avsvscalars_set
 *
 * Purpose:  This function is the set processing for scalar objects in
 * AVSV_SCALARS_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function does the set of the object and the corresponding actions
 * for the objects that are settable. This same function can be used for test
 * operation also.
 *
 * Input:  cb        - AVD control block
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         var_info  - The VAR INFO structure pointer generated by MIBLIB for
 *                     the objects in this table.
 *         test_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: Shutting down or LOCK of the cluster means shutdown of the system.
 *
 * 
 **************************************************************************/

uns32 avsvscalars_set(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                         NCSMIB_VAR_INFO* var_info, NCS_BOOL test_flag)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)cb;
   SaTimeT  new_intvl, old_intvl;

   if (avd_cb->cluster_admin_state != NCS_ADMIN_STATE_UNLOCK)
   {
      /* Invalid row status object */
      return NCSCC_RC_INV_VAL;  
   }

   
   switch(arg->req.info.set_req.i_param_val.i_param_id)
   {
   case ncsAvDHeartbeatSendInt_ID:
      new_intvl = m_NCS_OS_NTOHLL_P(arg->req.info.set_req.i_param_val.info.i_oct);
      if( (avd_cb->init_state == AVD_CFG_READY ) || 
          ( (new_intvl < (avd_cb->rcv_hb_intvl / 2)) &&
            (new_intvl > 10000000)
          ) 
        )
      {
         if (test_flag == FALSE)
         {
            old_intvl = avd_cb->snd_hb_intvl;
            avd_cb->snd_hb_intvl = new_intvl;
            /* check the AvD state is config done. send heartbeat info message.
             */
            if (avd_cb->init_state >= AVD_CFG_DONE)
            {
               if (NCSCC_RC_FAILURE == avd_snd_hbt_info_msg(avd_cb))
               {
                  avd_cb->snd_hb_intvl = old_intvl;
                  return NCSCC_RC_FAILURE;
               }
            }
            
            m_AVSV_SEND_CKPT_UPDT_ASYNC_UPDT(avd_cb, avd_cb, AVSV_CKPT_AVD_CB_CONFIG);
         }
      }else
      {
         return NCSCC_RC_INV_VAL;
      }
      break;
   case ncsAvDHeartbeatDownInt_ID:
      new_intvl = m_NCS_OS_NTOHLL_P(arg->req.info.set_req.i_param_val.info.i_oct);
      if( (avd_cb->init_state == AVD_CFG_READY ) || 
          (new_intvl > (avd_cb->snd_hb_intvl * (uns64)2)) )
      {
         if (test_flag == FALSE)
         {
            avd_cb->rcv_hb_intvl = new_intvl;
            m_AVSV_SEND_CKPT_UPDT_ASYNC_UPDT(avd_cb, avd_cb, AVSV_CKPT_AVD_CB_CONFIG);
         }
      }else
      {
         return NCSCC_RC_INV_VAL;
      }
      break;
   default:
      return NCSCC_RC_INV_VAL;
      break;
      
   } /* switch(param->i_param_id) */

   return NCSCC_RC_SUCCESS;

}



/*****************************************************************************
 * Function: avsvscalars_next
 *
 * Purpose:  This function is the next processing for objects in
 * AVSV_SCALARS_ID. This is a dummy function as sub agent shouldnt
 * call next operation for scalar objects.
 *
 * Input: cb        - AVD control block.
 *        arg       - The pointer to the MIB arg that was provided by the caller.
 *        data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *     next_inst_id - The next instance id will be filled in this buffer
 *                     and returned by reference.
 * next_inst_id_len - The next instance id length.
 *
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context
 *
 * NOTES: This function works in conjunction with extract function to provide the
 * getnext functionality.
 *
 * 
 **************************************************************************/

uns32 avsvscalars_next(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                           NCSCONTEXT* data, uns32* next_inst_id,
                           uns32 *next_inst_id_len)
{
   /* Invalid instance */
   return NCSCC_RC_NO_INSTANCE;
}


/*****************************************************************************
 * Function: avsvscalars_setrow
 *
 * Purpose:  This function is the setrow processing for scalar objects in
 * AVSV_SCALARS_ID. This is a dummy function as sub agent shouldnt allow
 * row operations on scalar.
 *
 * Input:  cb        - AVD control block
 *         args      - The pointer to the MIB arg that was provided by the caller.
 *         params    - The List of object ids and their values.
 *         obj_info  - The VAR INFO structure array pointer generated by MIBLIB for
 *                     the objects in this table.
 *      testrow_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: None.
 *
 * 
 **************************************************************************/

uns32 avsvscalars_setrow(NCSCONTEXT cb, NCSMIB_ARG* args,
                             NCSMIB_SETROW_PARAM_VAL* params,
                             struct ncsmib_obj_info* obj_info,
                             NCS_BOOL testrow_flag)
{
   /* Invalid instance */
   return NCSCC_RC_NO_INSTANCE;
}




/*****************************************************************************
 * Function: avsvscalars_rmvrow
 *
 * Purpose:  This function is one of the RMVROW processing routines for objects
 * in AVSV_SCALARS_ID table.
 *
 * Input:  cb        - AVD control block.
 *         idx       - pointer to NCSMIB_IDX
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 **************************************************************************/
uns32 avsvscalars_rmvrow(NCSCONTEXT cb, NCSMIB_IDX *idx)
{
   return NCSCC_RC_SUCCESS;
}


/*****************************************************************************
 * Function: saamfscalars_get
 *
 * Purpose:  This function is the get processing routine for the 
 * scalar objects in SA_AMF_SCALARS_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function returns the pointer to the CB data structure which
 * contains all the scalar information.
 *
 * Input:  cb        - AVD control block.
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 * NOTES: This function works in conjunction with extract function to provide the
 * get functionality.
 *
 * 
 **************************************************************************/

uns32 saamfscalars_get(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                                  NCSCONTEXT* data)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)cb;

   if (avd_cb->cluster_admin_state != NCS_ADMIN_STATE_UNLOCK)
   {
      /* Invalid instance as the system is going down. */
      return NCSCC_RC_NO_INSTANCE;
   }

   /* Fill the cb pointer to the data field and return */
   *data = (NCSCONTEXT)avd_cb;

   return NCSCC_RC_SUCCESS;
}

/*****************************************************************************
 * Function: saamfscalars_extract
 *
 * Purpose:  This function is the get processing function for scalar objects in
 * SA_AMF_SCALARS_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after calling the get call to get data structure.
 * This function fills the value information in the param filed structure. For
 * octate information the buffer field will be used for filling the information.
 * MIBLIB will provide the memory and pointer to the buffer. For only objects that
 * have a direct value(i.e their offset is not 0 in VAR INFO) in the structure
 * the data field is filled using the VAR INFO provided by MIBLIB, for others based
 * on the OID the value is filled accordingly.
 *
 * Input:  param     -  param->i_param_id indicates the parameter to extract
 *                      The remaining elements of the param need to be filled
 *                      by the subystem's extract function
 *         var_info  - Pointer to the var_info structure for the param.
 *         data      - The pointer to the data-structure containing the object
 *                     value which we have already provided to MIBLIB from get call.
 *         buffer    - The buffer pointer provided by MIBLIB for filling the octate
 *                     type data.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 *
 * NOTES:  This function works in conjunction with other functions to provide the
 * get functionality.
 *
 * 
 **************************************************************************/

uns32 saamfscalars_extract(NCSMIB_PARAM_VAL* param, 
                              NCSMIB_VAR_INFO* var_info, NCSCONTEXT data,
                              NCSCONTEXT buffer)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)data;

   if (avd_cb == AVD_CL_CB_NULL)
   {
      /* The row was not found */
      return NCSCC_RC_NO_INSTANCE;
   }

/*
  memset(&si_name, '\0', sizeof(SaNameT));
 temp_name.length = arg->req.info.set_req.i_param_val.i_length;
      memcpy(temp_name.value,
                   arg->req.info.set_req.i_param_val.info.i_oct,
                   temp_name.length);

m_AVSV_OCTVAL_TO_PARAM(param, buffer,si->sg_name.length,
                              si->sg_name.value);

 */


   switch(param->i_param_id)
   {
   case saAmfClusterStartupTimeout_ID:
       m_AVSV_UNS64_TO_PARAM(param,buffer,avd_cb->amf_init_intvl);
      break;
   case saAmfAgentSpecVersion_ID:
       m_AVSV_OCTVAL_TO_PARAM(param, buffer,19,
                              "SAI-AIS-AMF-B.01.01");
       break;
   case saAmfAgentVendor_ID:
       m_AVSV_OCTVAL_TO_PARAM(param, buffer,8,
                              "NET-SNMP");
       break;
   case saAmfAgentVendorProductRev_ID:
       param->i_fmat_id = NCSMIB_FMAT_INT;
       param->i_length = 1;
       param->info.i_int = 0;
       break;
   case saAmfServiceStartEnabled_ID:
       param->i_fmat_id = NCSMIB_FMAT_INT;
       param->i_length = 1;
       param->info.i_int = 2;
       break;
   default:
      /* call the MIBLIB utility routine for standard object types */
      if ((var_info != NULL) && (var_info->offset != 0))
         return ncsmiblib_get_obj_val(param, var_info, data, buffer);
      else
         return NCSCC_RC_NO_OBJECT;
      break;
   }
   return NCSCC_RC_SUCCESS;
}


/*****************************************************************************
 * Function: saamfscalars_set
 *
 * Purpose:  This function is the set processing for scalar objects in
 * SA_AMF_SCALARS_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function does the set of the object and the corresponding actions
 * for the objects that are settable. This same function can be used for test
 * operation also.
 *
 * Input:  cb        - AVD control block
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         var_info  - The VAR INFO structure pointer generated by MIBLIB for
 *                     the objects in this table.
 *         test_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: Shutting down or LOCK of the cluster means shutdown of the system.
 *
 * 
 **************************************************************************/

uns32 saamfscalars_set(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                         NCSMIB_VAR_INFO* var_info, NCS_BOOL test_flag)
{
  AVD_CL_CB     *avd_cb = (AVD_CL_CB *)cb;
   SaTimeT  new_intvl;

   if (avd_cb->cluster_admin_state != NCS_ADMIN_STATE_UNLOCK)
   {
      /* Invalid row status object */
      return NCSCC_RC_INV_VAL;
   }


   switch(arg->req.info.set_req.i_param_val.i_param_id)
   {
   case saAmfClusterStartupTimeout_ID:
      new_intvl = m_NCS_OS_NTOHLL_P(arg->req.info.set_req.i_param_val.info.i_oct);
      if (new_intvl > 10000000)
      {
         if (test_flag == FALSE)
            avd_cb->amf_init_intvl = new_intvl;
      }else
      {
         return NCSCC_RC_INV_VAL;
      }
      break;
   default:
      return NCSCC_RC_INV_VAL;
      break;

   } /* switch(param->i_param_id) */

   return NCSCC_RC_SUCCESS;

}   
   



/*****************************************************************************
 * Function: saamfscalars_next
 *
 * Purpose:  This function is the next processing for objects in
 * SA_AMF_SCALARS_ID. This is a dummy function as sub agent shouldnt
 * call next operation for scalar objects.
 *
 * Input: cb        - AVD control block.
 *        arg       - The pointer to the MIB arg that was provided by the caller.
 *        data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *     next_inst_id - The next instance id will be filled in this buffer
 *                     and returned by reference.
 * next_inst_id_len - The next instance id length.
 *
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context
 *
 * NOTES: This function works in conjunction with extract function to provide the
 * getnext functionality.
 *
 * 
 **************************************************************************/

uns32 saamfscalars_next(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                           NCSCONTEXT* data, uns32* next_inst_id,
                           uns32 *next_inst_id_len)
{
   /* Invalid instance */
   return NCSCC_RC_NO_INSTANCE;
}


/*****************************************************************************
 * Function: saamfscalars_setrow
 *
 * Purpose:  This function is the setrow processing for scalar objects in
 * SA_AMF_SCALARS_ID. This is a dummy function as sub agent shouldnt allow
 * row operations on scalar.
 *
 * Input:  cb        - AVD control block
 *         args      - The pointer to the MIB arg that was provided by the caller.
 *         params    - The List of object ids and their values.
 *         obj_info  - The VAR INFO structure array pointer generated by MIBLIB for
 *                     the objects in this table.
 *      testrow_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: None.
 *
 * 
 **************************************************************************/

uns32 saamfscalars_setrow(NCSCONTEXT cb, NCSMIB_ARG* args,
                             NCSMIB_SETROW_PARAM_VAL* params,
                             struct ncsmib_obj_info* obj_info,
                             NCS_BOOL testrow_flag)
{
   /* Invalid instance */
   return NCSCC_RC_NO_INSTANCE;
}



/*****************************************************************************
 * Function: saamfscalars_rmvrow
 *
 * Purpose:  This function is one of the RMVROW processing routines for objects
 * in SA_AMF_SCALARS_ID.
 *
 * Input:  cb        - AVD control block.
 *         idx       - pointer to NCSMIB_IDX
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 **************************************************************************/
uns32 saamfscalars_rmvrow(NCSCONTEXT cb, NCSMIB_IDX *idx)
{
   return NCSCC_RC_SUCCESS;
}



/*****************************************************************************
 * Function: safclmscalarobject_get
 *
 * Purpose:  This function is the get processing routine for the 
 * scalar objects in SAF_CLM_SCALAR_OBJECT_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function returns the pointer to the CB data structure which
 * contains all the scalar information.
 *
 * Input:  cb        - AVD control block.
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 * NOTES: This function works in conjunction with extract function to provide the
 * get functionality.
 *
 * 
 **************************************************************************/

uns32 safclmscalarobject_get(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                                  NCSCONTEXT* data)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)cb;

   if (avd_cb->cluster_admin_state != NCS_ADMIN_STATE_UNLOCK)
   {
      /* Invalid instance as the system is going down. */
      return NCSCC_RC_NO_INSTANCE;  
   }

   /* Fill the cb pointer to the data field and return */
   *data = (NCSCONTEXT)avd_cb;
   
   return NCSCC_RC_SUCCESS;
}

/*****************************************************************************
 * Function: safclmscalarobject_extract
 *
 * Purpose:  This function is the get processing function for scalar objects in
 * SAF_CLM_SCALAR_OBJECT_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after calling the get call to get data structure.
 * This function fills the value information in the param filed structure. For
 * octate information the buffer field will be used for filling the information.
 * MIBLIB will provide the memory and pointer to the buffer. For only objects that
 * have a direct value(i.e their offset is not 0 in VAR INFO) in the structure
 * the data field is filled using the VAR INFO provided by MIBLIB, for others based
 * on the OID the value is filled accordingly.
 *
 * Input:  param     -  param->i_param_id indicates the parameter to extract
 *                      The remaining elements of the param need to be filled
 *                      by the subystem's extract function
 *         var_info  - Pointer to the var_info structure for the param.
 *         data      - The pointer to the data-structure containing the object
 *                     value which we have already provided to MIBLIB from get call.
 *         buffer    - The buffer pointer provided by MIBLIB for filling the octate
 *                     type data.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 *
 * NOTES:  This function works in conjunction with other functions to provide the
 * get functionality.
 *
 * 
 **************************************************************************/

uns32 safclmscalarobject_extract(NCSMIB_PARAM_VAL* param, 
                              NCSMIB_VAR_INFO* var_info, NCSCONTEXT data,
                              NCSCONTEXT buffer)
{
   AVD_CL_CB     *avd_cb = (AVD_CL_CB *)data;
   
   if (avd_cb == AVD_CL_CB_NULL)
   {
      /* The row was not found */
      return NCSCC_RC_NO_INSTANCE;
   }

   switch(param->i_param_id)
   {
   case saClmClusterInitTime_ID:
      m_AVSV_UNS64_TO_PARAM(param,buffer,avd_cb->cluster_init_time);
      break;
   case saClmAgentSpecVersion_ID:
       m_AVSV_OCTVAL_TO_PARAM(param, buffer,19,
                              "SAI-AIS-CLM-B.01.01");
       break;
   case saClmAgentVendor_ID:
       m_AVSV_OCTVAL_TO_PARAM(param, buffer,8,
                              "NET-SNMP");
       break;
   case saClmAgentVendorProductRev_ID:
       param->i_fmat_id = NCSMIB_FMAT_INT;
       param->i_length = 1;
       param->info.i_int = 0;
       break;
   case saClmServiceStartEnabled_ID:
       param->i_fmat_id = NCSMIB_FMAT_INT;
       param->i_length = 1;
       param->info.i_int = 1;
       break;
   default:
      /* call the MIBLIB utility routine for standard object types */
      if ((var_info != NULL) && (var_info->offset != 0))
         return ncsmiblib_get_obj_val(param, var_info, data, buffer);
      else
         return NCSCC_RC_NO_OBJECT;
      break;
   }
   return NCSCC_RC_SUCCESS;
}


/*****************************************************************************
 * Function: safclmscalarobject_set
 *
 * Purpose:  This function is the set processing for scalar objects in
 * SAF_CLM_SCALAR_OBJECT_ID. This is treated as a table. The
 * name of this function is generated by the MIBLIB tool. This function
 * will be called by MIBLIB after validating the arg information.
 * This function does the set of the object and the corresponding actions
 * for the objects that are settable. This same function can be used for test
 * operation also.
 *
 * Input:  cb        - AVD control block
 *         arg       - The pointer to the MIB arg that was provided by the caller.
 *         var_info  - The VAR INFO structure pointer generated by MIBLIB for
 *                     the objects in this table.
 *         test_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: Shutting down or LOCK of the cluster means shutdown of the system.
 *
 * 
 **************************************************************************/

uns32 safclmscalarobject_set(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                         NCSMIB_VAR_INFO* var_info, NCS_BOOL test_flag)
{
   
   
   /* currently invalid value */
   return NCSCC_RC_INV_VAL;
}



/*****************************************************************************
 * Function: safclmscalarobject_next
 *
 * Purpose:  This function is the next processing for objects in
 * SAF_CLM_SCALAR_OBJECT_ID. This is a dummy function as sub agent shouldnt
 * call next operation for scalar objects.
 *
 * Input: cb        - AVD control block.
 *        arg       - The pointer to the MIB arg that was provided by the caller.
 *        data      - The pointer to the data-structure containing the object
 *                     value is returned by reference.
 *     next_inst_id - The next instance id will be filled in this buffer
 *                     and returned by reference.
 * next_inst_id_len - The next instance id length.
 *
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context
 *
 * NOTES: This function works in conjunction with extract function to provide the
 * getnext functionality.
 *
 * 
 **************************************************************************/

uns32 safclmscalarobject_next(NCSCONTEXT cb, NCSMIB_ARG *arg, 
                           NCSCONTEXT* data, uns32* next_inst_id,
                           uns32 *next_inst_id_len)
{
   /* Invalid instance */
   return NCSCC_RC_NO_INSTANCE;
}


/*****************************************************************************
 * Function: safclmscalarobject_setrow
 *
 * Purpose:  This function is the setrow processing for scalar objects in
 * SAF_CLM_SCALAR_OBJECT_ID. This is a dummy function as sub agent shouldnt allow
 * row operations on scalar.
 *
 * Input:  cb        - AVD control block
 *         args      - The pointer to the MIB arg that was provided by the caller.
 *         params    - The List of object ids and their values.
 *         obj_info  - The VAR INFO structure array pointer generated by MIBLIB for
 *                     the objects in this table.
 *      testrow_flag - The flag that indicates if this is set or test.
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *          to set the args->rsp.i_status field before returning the
 *          NCSMIB_ARG to the caller's context.
 *
 * NOTES: None.
 *
 * 
 **************************************************************************/

uns32 safclmscalarobject_setrow(NCSCONTEXT cb, NCSMIB_ARG* args,
                             NCSMIB_SETROW_PARAM_VAL* params,
                             struct ncsmib_obj_info* obj_info,
                             NCS_BOOL testrow_flag)
{
   /* Invalid instance */
   return NCSCC_RC_NO_INSTANCE;
}



/*****************************************************************************
 * Function: safclmscalarobject_rmvrow
 *
 * Purpose:  This function is one of the RMVROW processing routines for objects
 * in SA_CLM_SCALARS_OBJECT_ID.
 *
 * Input:  cb        - AVD control block.
 *         idx       - pointer to NCSMIB_IDX
 *
 * Returns: The status returned by the operation. MIB lib will use it
 *                   to set the args->rsp.i_status field before returning the
 *                   NCSMIB_ARG to the caller's context
 **************************************************************************/
uns32 safclmscalarobject_rmvrow(NCSCONTEXT cb, NCSMIB_IDX *idx)
{
   return NCSCC_RC_SUCCESS;
}



/*****************************************************************************
 * Function: avd_req_mib_func
 *
 * Purpose:  This function is the handler for MIB request events. This
 * function calls the MIBLIB API to do the initial validation for the
 * MIB arg structure received and then calls the appropriate table
 * handling routine.
 *
 * Input:  cb - AVD control block
 *         evt - The event information.
 *
 * Returns: None
 *
 * NOTES: None.
 *
 * 
 **************************************************************************/

void avd_req_mib_func(AVD_CL_CB *cb,AVD_EVT *evt)
{
   
   NCSMIBLIB_REQ_INFO  miblib_req;

   m_AVD_LOG_FUNC_ENTRY("avd_req_mib_func");
   
   if (evt->info.mib_req == NULL)
   {
      /* log error that a message contents is missing */
      m_AVD_LOG_INVALID_VAL_ERROR(0);
      return;
   }

   m_AVD_LOG_RCVD_VAL(((long)evt->info.mib_req));
   
   if ((cb->init_state != AVD_CFG_READY) && (cb->init_state != AVD_APP_STATE)) 
   {
      /* Don't initialise the AvND when the AVD is not
       * completely initialised with the saved information
       */
      
      /* Log an information message that the AvD is not yet operationally
       * up to take MIB requests.
       */
      avd_log(NCSFL_SEV_WARNING, "invalid avd init_state %u", cb->init_state);
      evt->info.mib_req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      evt->info.mib_req->i_op = m_NCSMIB_REQ_TO_RSP(evt->info.mib_req->i_op);
      evt->info.mib_req->i_rsp_fnc(evt->info.mib_req);
      return;
   }

   if((cb->init_state >= AVD_CFG_DONE) && 
     (evt->info.mib_req->i_policy & NCSMIB_POLICY_PSS_BELIEVE_ME ))
   {
   /* On demand PSS playback not supported */
      m_AVD_LOG_INVALID_VAL_ERROR(cb->init_state);
      evt->info.mib_req->rsp.i_status = NCSCC_RC_FAILURE;
      evt->info.mib_req->i_op = m_NCSMIB_REQ_TO_RSP(evt->info.mib_req->i_op);
      evt->info.mib_req->i_rsp_fnc(evt->info.mib_req);
      return;
   }

   memset(&miblib_req, '\0', sizeof(NCSMIBLIB_REQ_INFO)); 

   miblib_req.req = NCSMIBLIB_REQ_MIB_OP; 
   miblib_req.info.i_mib_op_info.args = evt->info.mib_req;
   miblib_req.info.i_mib_op_info.cb = cb;
   
   if((evt->info.mib_req->i_op == NCSMIB_OP_REQ_GET) ||
         (evt->info.mib_req->i_op == NCSMIB_OP_REQ_NEXT))
   {
      cb->sync_required = FALSE;
   }
   else if( (evt->info.mib_req->i_op == NCSMIB_OP_REQ_SET) && 
           (cb->init_state == AVD_CFG_READY) )
   {
      cb->num_cfg_msgs++;
   }

   /* call the mib routine handler */ 
   ncsmiblib_process_req(&miblib_req);

  if((m_NCSMIB_PSSV_PLBCK_IS_LAST_EVENT(evt->info.mib_req->i_policy) == TRUE) && 
     (cb->init_state == AVD_CFG_READY) )
   {
      /* stop the cfg_tmr */
      avd_stop_tmr(cb, &cb->init_phase_tmr.cfg_tmr);
      cb->init_state = AVD_CFG_DONE;
   }


   /* free the MIB arg structure. This MIB arg is a
    * copy made by us, Since we have already processed it free it. 
    */
   ncsmib_memfree(evt->info.mib_req);
   evt->info.mib_req = NULL;
   
   return;
}


/*****************************************************************************
 * Function: avd_qsd_req_mib_func
 *
 * Purpose:  This function is the handler for MIB request events in quiesced
 *           state. Since we are in quiesced state we should respond failure
 *           for all request.
 *
 * Input:  cb - AVD control block
 *         evt - The event information.
 *
 * Returns: None
 *
 * NOTES: None.
 *
 * 
 **************************************************************************/

void avd_qsd_req_mib_func(AVD_CL_CB *cb,AVD_EVT *evt)
{
   

   NCSMIBLIB_REQ_INFO  miblib_req;
   
   m_AVD_LOG_FUNC_ENTRY("avd_qsd_req_mib_func");
   
   if (evt->info.mib_req == NULL)
   {
      /* log error that a message contents is missing */
      m_AVD_LOG_INVALID_VAL_ERROR(0);
      return;
   }

   m_AVD_LOG_RCVD_VAL(((long)evt->info.mib_req));
   
   if ((cb->init_state != AVD_CFG_READY) && (cb->init_state != AVD_APP_STATE))
   {    
   /* Log an information message that the AvD will not take 
    * up any new MIB requests in stis state.
    */
      m_AVD_LOG_INVALID_VAL_ERROR(cb->init_state);
      evt->info.mib_req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
      evt->info.mib_req->i_op = m_NCSMIB_REQ_TO_RSP(evt->info.mib_req->i_op);
      evt->info.mib_req->i_rsp_fnc(evt->info.mib_req);
      return;
    }

   memset(&miblib_req, '\0', sizeof(NCSMIBLIB_REQ_INFO));

   miblib_req.req = NCSMIBLIB_REQ_MIB_OP;
   miblib_req.info.i_mib_op_info.args = evt->info.mib_req;
   miblib_req.info.i_mib_op_info.cb = cb;

   if((evt->info.mib_req->i_op == NCSMIB_OP_REQ_GET) ||
      (evt->info.mib_req->i_op == NCSMIB_OP_REQ_NEXT))
   {
      cb->sync_required = FALSE;

      ncsmiblib_process_req(&miblib_req);
      ncsmib_memfree(evt->info.mib_req);
      evt->info.mib_req = NULL;

   }
   else
   {
     /* Log an information message that the AvD will not take 
     * up any new MIB requests other than GET/NEXT in this state.
     */
     m_AVD_LOG_INVALID_VAL_ERROR(cb->init_state);
     evt->info.mib_req->rsp.i_status = NCSCC_RC_NO_INSTANCE;
     evt->info.mib_req->i_op = m_NCSMIB_REQ_TO_RSP(evt->info.mib_req->i_op);
     evt->info.mib_req->i_rsp_fnc(evt->info.mib_req);
   }

   return;    

}
